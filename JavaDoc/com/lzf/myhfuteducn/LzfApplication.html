<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="zh">
<head>
<!-- Generated by javadoc (1.8.0_152-release) on Wed Feb 27 11:42:10 CST 2019 -->
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>LzfApplication</title>
<meta name="date" content="2019-02-27">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="LzfApplication";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":10,"i1":10,"i2":10,"i3":10,"i4":10,"i5":10,"i6":10,"i7":10,"i8":10,"i9":10,"i10":10,"i11":10,"i12":10,"i13":10,"i14":10,"i15":10,"i16":10,"i17":10,"i18":10,"i19":10,"i20":10,"i21":10,"i22":10,"i23":10,"i24":10,"i25":10,"i26":10,"i27":10,"i28":10,"i29":10,"i30":10,"i31":10,"i32":10,"i33":10,"i34":10,"i35":10,"i36":10,"i37":10,"i38":10,"i39":9,"i40":10,"i41":10,"i42":10,"i43":10,"i44":10,"i45":10,"i46":10,"i47":10,"i48":10,"i49":10,"i50":10,"i51":10,"i52":10,"i53":10,"i54":10,"i55":10,"i56":10,"i57":10,"i58":10,"i59":10,"i60":10,"i61":10,"i62":10,"i63":10,"i64":10,"i65":10,"i66":10,"i67":10,"i68":10,"i69":10,"i70":10,"i71":10,"i72":10,"i73":10,"i74":10,"i75":10,"i76":10,"i77":10,"i78":10,"i79":10,"i80":10,"i81":10,"i82":10,"i83":10,"i84":10,"i85":10,"i86":10,"i87":10,"i88":10,"i89":10,"i90":10,"i91":10,"i92":10,"i93":10,"i94":10,"i95":10,"i96":10,"i97":10,"i98":10,"i99":10,"i100":10,"i101":10,"i102":10,"i103":10,"i104":10,"i105":10,"i106":10,"i107":10,"i108":10,"i109":10,"i110":10,"i111":10,"i112":10,"i113":10,"i114":10,"i115":10,"i116":10,"i117":10,"i118":10,"i119":10,"i120":10,"i121":10,"i122":10};
var tabs = {65535:["t0","所有方法"],1:["t1","静态方法"],2:["t2","实例方法"],8:["t4","具体方法"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>您的浏览器已禁用 JavaScript。</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="跳过导航链接">跳过导航链接</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="导航">
<li><a href="../../../overview-summary.html">概览</a></li>
<li><a href="package-summary.html">程序包</a></li>
<li class="navBarCell1Rev">类</li>
<li><a href="class-use/LzfApplication.html">使用</a></li>
<li><a href="package-tree.html">树</a></li>
<li><a href="../../../deprecated-list.html">已过时</a></li>
<li><a href="../../../index-files/index-1.html">索引</a></li>
<li><a href="../../../help-doc.html">帮助</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../com/lzf/myhfuteducn/LoginActivity.html" title="com.lzf.myhfuteducn中的类"><span class="typeNameLink">上一个类</span></a></li>
<li><a href="../../../com/lzf/myhfuteducn/MainActivity.html" title="com.lzf.myhfuteducn中的类"><span class="typeNameLink">下一个类</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?com/lzf/myhfuteducn/LzfApplication.html" target="_top">框架</a></li>
<li><a href="LzfApplication.html" target="_top">无框架</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../allclasses-noframe.html">所有类</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>概要:&nbsp;</li>
<li><a href="#nested.classes.inherited.from.class.android.app.Application">嵌套</a>&nbsp;|&nbsp;</li>
<li><a href="#fields.inherited.from.class.android.content.Context">字段</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">构造器</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">方法</a></li>
</ul>
<ul class="subNavList">
<li>详细资料:&nbsp;</li>
<li>字段&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">构造器</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">方法</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">com.lzf.myhfuteducn</div>
<h2 title="类 LzfApplication" class="title">类 LzfApplication</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>android.content.Context</li>
<li>
<ul class="inheritance">
<li>android.content.ContextWrapper</li>
<li>
<ul class="inheritance">
<li>android.app.Application</li>
<li>
<ul class="inheritance">
<li>com.lzf.myhfuteducn.LzfApplication</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>所有已实现的接口:</dt>
<dd>android.content.ComponentCallbacks, android.content.ComponentCallbacks2</dd>
</dl>
<hr>
<br>
<pre>public class <span class="typeNameLabel">LzfApplication</span>
extends android.app.Application</pre>
<div class="block">Android系统在每个程序运行的时候都会仅且只创建一个Application对象，所以Application 是单例(singleton)模式的一个类，而且Application对象的生命周期是整个程序中最长的，
 Application对象的生命周期等于这个程序的生命周期。</div>
<dl>
<dt><span class="simpleTagLabel">作者:</span></dt>
<dd>MJCoder</dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><code>Application</code></dd>
</dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="nested.class.summary">
<!--   -->
</a>
<h3>嵌套类概要</h3>
<ul class="blockList">
<li class="blockList"><a name="nested.classes.inherited.from.class.android.app.Application">
<!--   -->
</a>
<h3>从类继承的嵌套类/接口&nbsp;android.app.Application</h3>
<code>android.app.Application.ActivityLifecycleCallbacks, android.app.Application.OnProvideAssistDataListener</code></li>
</ul>
</li>
</ul>
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.summary">
<!--   -->
</a>
<h3>字段概要</h3>
<ul class="blockList">
<li class="blockList"><a name="fields.inherited.from.class.android.content.Context">
<!--   -->
</a>
<h3>从类继承的字段&nbsp;android.content.Context</h3>
<code>ACCESSIBILITY_SERVICE, ACCOUNT_SERVICE, ACTIVITY_SERVICE, ALARM_SERVICE, APP_OPS_SERVICE, APPWIDGET_SERVICE, AUDIO_SERVICE, BATTERY_SERVICE, BIND_ABOVE_CLIENT, BIND_ADJUST_WITH_ACTIVITY, BIND_ALLOW_OOM_MANAGEMENT, BIND_AUTO_CREATE, BIND_DEBUG_UNBIND, BIND_EXTERNAL_SERVICE, BIND_IMPORTANT, BIND_NOT_FOREGROUND, BIND_WAIVE_PRIORITY, BLUETOOTH_SERVICE, CAMERA_SERVICE, CAPTIONING_SERVICE, CARRIER_CONFIG_SERVICE, CLIPBOARD_SERVICE, COMPANION_DEVICE_SERVICE, CONNECTIVITY_SERVICE, CONSUMER_IR_SERVICE, CONTEXT_IGNORE_SECURITY, CONTEXT_INCLUDE_CODE, CONTEXT_RESTRICTED, CROSS_PROFILE_APPS_SERVICE, DEVICE_POLICY_SERVICE, DISPLAY_SERVICE, DOWNLOAD_SERVICE, DROPBOX_SERVICE, EUICC_SERVICE, FINGERPRINT_SERVICE, HARDWARE_PROPERTIES_SERVICE, INPUT_METHOD_SERVICE, INPUT_SERVICE, IPSEC_SERVICE, JOB_SCHEDULER_SERVICE, KEYGUARD_SERVICE, LAUNCHER_APPS_SERVICE, LAYOUT_INFLATER_SERVICE, LOCATION_SERVICE, MEDIA_PROJECTION_SERVICE, MEDIA_ROUTER_SERVICE, MEDIA_SESSION_SERVICE, MIDI_SERVICE, MODE_APPEND, MODE_ENABLE_WRITE_AHEAD_LOGGING, MODE_MULTI_PROCESS, MODE_NO_LOCALIZED_COLLATORS, MODE_PRIVATE, MODE_WORLD_READABLE, MODE_WORLD_WRITEABLE, NETWORK_STATS_SERVICE, NFC_SERVICE, NOTIFICATION_SERVICE, NSD_SERVICE, POWER_SERVICE, PRINT_SERVICE, RECEIVER_VISIBLE_TO_INSTANT_APPS, RESTRICTIONS_SERVICE, SEARCH_SERVICE, SENSOR_SERVICE, SHORTCUT_SERVICE, STORAGE_SERVICE, STORAGE_STATS_SERVICE, SYSTEM_HEALTH_SERVICE, TELECOM_SERVICE, TELEPHONY_SERVICE, TELEPHONY_SUBSCRIPTION_SERVICE, TEXT_CLASSIFICATION_SERVICE, TEXT_SERVICES_MANAGER_SERVICE, TV_INPUT_SERVICE, UI_MODE_SERVICE, USAGE_STATS_SERVICE, USB_SERVICE, USER_SERVICE, VIBRATOR_SERVICE, WALLPAPER_SERVICE, WIFI_AWARE_SERVICE, WIFI_P2P_SERVICE, WIFI_RTT_RANGING_SERVICE, WIFI_SERVICE, WINDOW_SERVICE</code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="fields.inherited.from.class.android.content.ComponentCallbacks2">
<!--   -->
</a>
<h3>从接口继承的字段&nbsp;android.content.ComponentCallbacks2</h3>
<code>TRIM_MEMORY_BACKGROUND, TRIM_MEMORY_COMPLETE, TRIM_MEMORY_MODERATE, TRIM_MEMORY_RUNNING_CRITICAL, TRIM_MEMORY_RUNNING_LOW, TRIM_MEMORY_RUNNING_MODERATE, TRIM_MEMORY_UI_HIDDEN</code></li>
</ul>
</li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.summary">
<!--   -->
</a>
<h3>构造器概要</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="构造器概要表, 列表构造器和解释">
<caption><span>构造器</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">构造器和说明</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#LzfApplication--">LzfApplication</a></span>()</code>
<div class="block">无参构造方法</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>方法概要</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="方法概要表, 列表方法和解释">
<caption><span id="t0" class="activeTableTab"><span>所有方法</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">静态方法</a></span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">实例方法</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">具体方法</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">限定符和类型</th>
<th class="colLast" scope="col">方法和说明</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>protected void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#attachBaseContext-android.content.Context-">attachBaseContext</a></span>(android.content.Context&nbsp;base)</code>
<div class="block">Set the base context for this ContextWrapper.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#bindService-android.content.Intent-android.content.ServiceConnection-int-">bindService</a></span>(android.content.Intent&nbsp;service,
           android.content.ServiceConnection&nbsp;conn,
           int&nbsp;flags)</code>
<div class="block">连接到应用程序服务，根据需要创建它。</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#checkCallingOrSelfPermission-java.lang.String-">checkCallingOrSelfPermission</a></span>(java.lang.String&nbsp;permission)</code>
<div class="block">确定IPC（Inter-Process Communication：跨进程通信）或您的调用进程是否已被授予特定权限。</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#checkCallingOrSelfUriPermission-android.net.Uri-int-">checkCallingOrSelfUriPermission</a></span>(android.net.Uri&nbsp;uri,
                               int&nbsp;modeFlags)</code>
<div class="block">确定IPC 或 调用进程是否已被授予访问特定URI的权限。</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#checkCallingPermission-java.lang.String-">checkCallingPermission</a></span>(java.lang.String&nbsp;permission)</code>
<div class="block">确定您正在处理的IPC的调用进程是否已被授予特定权限。</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#checkCallingUriPermission-android.net.Uri-int-">checkCallingUriPermission</a></span>(android.net.Uri&nbsp;uri,
                         int&nbsp;modeFlags)</code>
<div class="block">确定是否已授予调用进程和用户标识访问特定URI的权限。</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#checkPermission-java.lang.String-int-int-">checkPermission</a></span>(java.lang.String&nbsp;permission,
               int&nbsp;pid,
               int&nbsp;uid)</code>
<div class="block">检查特定的包是否获得了特定的权限。</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#checkSelfPermission-java.lang.String-">checkSelfPermission</a></span>(java.lang.String&nbsp;permission)</code>
<div class="block">确定是否获得了特定的权限。</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#checkUriPermission-android.net.Uri-int-int-int-">checkUriPermission</a></span>(android.net.Uri&nbsp;uri,
                  int&nbsp;pid,
                  int&nbsp;uid,
                  int&nbsp;modeFlags)</code>
<div class="block">确定是否已授予特定进程和用户标识访问特定URI的权限。</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#checkUriPermission-android.net.Uri-java.lang.String-java.lang.String-int-int-int-">checkUriPermission</a></span>(android.net.Uri&nbsp;uri,
                  java.lang.String&nbsp;readPermission,
                  java.lang.String&nbsp;writePermission,
                  int&nbsp;pid,
                  int&nbsp;uid,
                  int&nbsp;modeFlags)</code>
<div class="block">检查Uri和正常权限。</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#clearWallpaper--">clearWallpaper</a></span>()</code>
<div class="block">删除任何当前设置的系统壁纸，恢复到系统的内置壁纸。</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>protected java.lang.Object</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#clone--">clone</a></span>()</code>
<div class="block">Creates and returns a copy of this object.</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>android.content.Context</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#createConfigurationContext-android.content.res.Configuration-">createConfigurationContext</a></span>(android.content.res.Configuration&nbsp;overrideConfiguration)</code>
<div class="block">为当前Context返回一个新的Context对象，但调整其资源以匹配给定的Configuration。</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>android.content.Context</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#createContextForSplit-java.lang.String-">createContextForSplit</a></span>(java.lang.String&nbsp;splitName)</code>
<div class="block">返回给定拆分名称的新Context对象。</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>android.content.Context</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#createDeviceProtectedStorageContext--">createDeviceProtectedStorageContext</a></span>()</code>
<div class="block">返回当前Context的新Context对象，但其存储API由受设备保护的存储支持。</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code>android.content.Context</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#createDisplayContext-android.view.Display-">createDisplayContext</a></span>(android.view.Display&nbsp;display)</code>
<div class="block">为当前Context返回一个新的Context对象，但调整其资源以匹配给定Display的度量。</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code>android.content.Context</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#createPackageContext-java.lang.String-int-">createPackageContext</a></span>(java.lang.String&nbsp;packageName,
                    int&nbsp;flags)</code>
<div class="block">返回给定应用程序名称的新Context对象。</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code>java.lang.String[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#databaseList--">databaseList</a></span>()</code>
<div class="block">一系列数据库</div>
</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#deleteDatabase-java.lang.String-">deleteDatabase</a></span>(java.lang.String&nbsp;name)</code>
<div class="block">删除数据库</div>
</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#deleteFile-java.lang.String-">deleteFile</a></span>(java.lang.String&nbsp;name)</code>
<div class="block">删除指定名称的文件</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#deleteSharedPreferences-java.lang.String-">deleteSharedPreferences</a></span>(java.lang.String&nbsp;name)</code>
<div class="block">删除配置文件名(自定义)为name的SharedPreferences</div>
</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#enforceCallingOrSelfPermission-java.lang.String-java.lang.String-">enforceCallingOrSelfPermission</a></span>(java.lang.String&nbsp;permission,
                              java.lang.String&nbsp;message)</code>
<div class="block">如果您和您正在处理的IPC的调用进程都未被授予特定权限，请抛出<code>SecurityException</code>。</div>
</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#enforceCallingOrSelfUriPermission-android.net.Uri-int-java.lang.String-">enforceCallingOrSelfUriPermission</a></span>(android.net.Uri&nbsp;uri,
                                 int&nbsp;modeFlags,
                                 java.lang.String&nbsp;message)</code>
<div class="block">如果IPC  或调用进程未被授予访问特定URI的权限，请抛出<code>SecurityException</code>。</div>
</td>
</tr>
<tr id="i23" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#enforceCallingPermission-java.lang.String-java.lang.String-">enforceCallingPermission</a></span>(java.lang.String&nbsp;permission,
                        java.lang.String&nbsp;message)</code>
<div class="block">如果您正在处理的IPC的调用进程未被授予特定权限，请抛出<code>SecurityException</code>。</div>
</td>
</tr>
<tr id="i24" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#enforceCallingUriPermission-android.net.Uri-int-java.lang.String-">enforceCallingUriPermission</a></span>(android.net.Uri&nbsp;uri,
                           int&nbsp;modeFlags,
                           java.lang.String&nbsp;message)</code>
<div class="block">如果未授予调用进程和用户标识访问特定URI的权限，请抛出<code>SecurityException</code>。</div>
</td>
</tr>
<tr id="i25" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#enforcePermission-java.lang.String-int-int-java.lang.String-">enforcePermission</a></span>(java.lang.String&nbsp;permission,
                 int&nbsp;pid,
                 int&nbsp;uid,
                 java.lang.String&nbsp;message)</code>
<div class="block">如果对系统中运行的特定进程和用户标识不允许给定权限，则抛出<code>SecurityException</code>。</div>
</td>
</tr>
<tr id="i26" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#enforceUriPermission-android.net.Uri-int-int-int-java.lang.String-">enforceUriPermission</a></span>(android.net.Uri&nbsp;uri,
                    int&nbsp;pid,
                    int&nbsp;uid,
                    int&nbsp;modeFlags,
                    java.lang.String&nbsp;message)</code>
<div class="block">如果未授予特定进程和用户标识访问特定URI的权限，请抛出<code>SecurityException</code>。</div>
</td>
</tr>
<tr id="i27" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#enforceUriPermission-android.net.Uri-java.lang.String-java.lang.String-int-int-int-java.lang.String-">enforceUriPermission</a></span>(android.net.Uri&nbsp;uri,
                    java.lang.String&nbsp;readPermission,
                    java.lang.String&nbsp;writePermission,
                    int&nbsp;pid,
                    int&nbsp;uid,
                    int&nbsp;modeFlags,
                    java.lang.String&nbsp;message)</code>
<div class="block">强制执行Uri和正常权限。</div>
</td>
</tr>
<tr id="i28" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#equals-java.lang.Object-">equals</a></span>(java.lang.Object&nbsp;obj)</code>
<div class="block">Indicates whether some other object is "equal to" this one.</div>
</td>
</tr>
<tr id="i29" class="rowColor">
<td class="colFirst"><code>java.lang.String[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#fileList--">fileList</a></span>()</code>
<div class="block">文件列表</div>
</td>
</tr>
<tr id="i30" class="altColor">
<td class="colFirst"><code>protected void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#finalize--">finalize</a></span>()</code>
<div class="block">Called by the garbage collector on an object when garbage collection
 determines that there are no more references to the object.</div>
</td>
</tr>
<tr id="i31" class="rowColor">
<td class="colFirst"><code>android.content.Context</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#getApplicationContext--">getApplicationContext</a></span>()</code>
<div class="block">获取应用的环境/上下文</div>
</td>
</tr>
<tr id="i32" class="altColor">
<td class="colFirst"><code>android.content.pm.ApplicationInfo</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#getApplicationInfo--">getApplicationInfo</a></span>()</code>
<div class="block">获取ApplicationInfo对象：可以检索有关特定应用程序的信息。</div>
</td>
</tr>
<tr id="i33" class="rowColor">
<td class="colFirst"><code>android.content.res.AssetManager</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#getAssets--">getAssets</a></span>()</code>
<div class="block">assets文件夹里面的文件都是保持原始的文件格式，需要用AssetManager以字节流的形式读取文件。</div>
</td>
</tr>
<tr id="i34" class="altColor">
<td class="colFirst"><code>android.content.Context</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#getBaseContext--">getBaseContext</a></span>()</code>&nbsp;</td>
</tr>
<tr id="i35" class="rowColor">
<td class="colFirst"><code>java.io.File</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#getCacheDir--">getCacheDir</a></span>()</code>
<div class="block">获取保存应用程序缓存文件的目录的路径。</div>
</td>
</tr>
<tr id="i36" class="altColor">
<td class="colFirst"><code>java.lang.ClassLoader</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#getClassLoader--">getClassLoader</a></span>()</code>
<div class="block">获取用于启动主应用程序的类装入器。</div>
</td>
</tr>
<tr id="i37" class="rowColor">
<td class="colFirst"><code>java.io.File</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#getCodeCacheDir--">getCodeCacheDir</a></span>()</code>
<div class="block">获取保存应用程序代码缓存文件的目录的路径。</div>
</td>
</tr>
<tr id="i38" class="altColor">
<td class="colFirst"><code>android.content.ContentResolver</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#getContentResolver--">getContentResolver</a></span>()</code>
<div class="block">获取ContentResolver对象：此类为应用程序提供对内容模型的访问权限。</div>
</td>
</tr>
<tr id="i39" class="rowColor">
<td class="colFirst"><code>static android.content.Context</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#getContext--">getContext</a></span>()</code>
<div class="block">获取环境/上下文实例</div>
</td>
</tr>
<tr id="i40" class="altColor">
<td class="colFirst"><code>java.io.File</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#getDatabasePath-java.lang.String-">getDatabasePath</a></span>(java.lang.String&nbsp;name)</code>
<div class="block">获取数据库的路径</div>
</td>
</tr>
<tr id="i41" class="rowColor">
<td class="colFirst"><code>java.io.File</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#getDataDir--">getDataDir</a></span>()</code>
<div class="block">获取数据的目录</div>
</td>
</tr>
<tr id="i42" class="altColor">
<td class="colFirst"><code>java.io.File</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#getDir-java.lang.String-int-">getDir</a></span>(java.lang.String&nbsp;name,
      int&nbsp;mode)</code>
<div class="block">获取请求目录的<code>File</code>对象。</div>
</td>
</tr>
<tr id="i43" class="rowColor">
<td class="colFirst"><code>java.io.File</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#getExternalCacheDir--">getExternalCacheDir</a></span>()</code>
<div class="block">获取应用程序特定目录的绝对路径。</div>
</td>
</tr>
<tr id="i44" class="altColor">
<td class="colFirst"><code>java.io.File[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#getExternalCacheDirs--">getExternalCacheDirs</a></span>()</code>
<div class="block">获取应用程序一系列特定目录的绝对路径。</div>
</td>
</tr>
<tr id="i45" class="rowColor">
<td class="colFirst"><code>java.io.File</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#getExternalFilesDir-java.lang.String-">getExternalFilesDir</a></span>(java.lang.String&nbsp;type)</code>
<div class="block">获取外部存储文件目录</div>
</td>
</tr>
<tr id="i46" class="altColor">
<td class="colFirst"><code>java.io.File[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#getExternalFilesDirs-java.lang.String-">getExternalFilesDirs</a></span>(java.lang.String&nbsp;type)</code>
<div class="block">获取一系列外部存储文件目录</div>
</td>
</tr>
<tr id="i47" class="rowColor">
<td class="colFirst"><code>java.io.File[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#getExternalMediaDirs--">getExternalMediaDirs</a></span>()</code>
<div class="block">获取应用程序一系列特定目录的绝对路径。</div>
</td>
</tr>
<tr id="i48" class="altColor">
<td class="colFirst"><code>java.io.File</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#getFilesDir--">getFilesDir</a></span>()</code>
<div class="block">获取内部存储文件的目录</div>
</td>
</tr>
<tr id="i49" class="rowColor">
<td class="colFirst"><code>java.io.File</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#getFileStreamPath-java.lang.String-">getFileStreamPath</a></span>(java.lang.String&nbsp;name)</code>
<div class="block">获取文件流路径</div>
</td>
</tr>
<tr id="i50" class="altColor">
<td class="colFirst"><code>android.os.Looper</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#getMainLooper--">getMainLooper</a></span>()</code>
<div class="block">获取Looper对象：用于为线程运行消息循环的类。</div>
</td>
</tr>
<tr id="i51" class="rowColor">
<td class="colFirst"><code>java.io.File</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#getNoBackupFilesDir--">getNoBackupFilesDir</a></span>()</code>
<div class="block">获取内部存储未备份的文件目录</div>
</td>
</tr>
<tr id="i52" class="altColor">
<td class="colFirst"><code>java.io.File</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#getObbDir--">getObbDir</a></span>()</code>
<div class="block">返回所有共享/外部存储设备上特定于应用程序的目录的绝对路径，其中可以找到应用程序的OBB文件（如果有）。</div>
</td>
</tr>
<tr id="i53" class="rowColor">
<td class="colFirst"><code>java.io.File[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#getObbDirs--">getObbDirs</a></span>()</code>
<div class="block">返回所有共享/外部存储设备上特定于应用程序的目录的绝对路径，其中可以找到应用程序的OBB文件（如果有）。</div>
</td>
</tr>
<tr id="i54" class="altColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#getPackageCodePath--">getPackageCodePath</a></span>()</code>
<div class="block">获取该程序的安装包代码路径</div>
</td>
</tr>
<tr id="i55" class="rowColor">
<td class="colFirst"><code>android.content.pm.PackageManager</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#getPackageManager--">getPackageManager</a></span>()</code>
<div class="block">获得一个PackageManger对象：用于检索与当前安装在设备上的应用程序包相关的各种信息的类。</div>
</td>
</tr>
<tr id="i56" class="altColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#getPackageName--">getPackageName</a></span>()</code>
<div class="block">获取包名</div>
</td>
</tr>
<tr id="i57" class="rowColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#getPackageResourcePath--">getPackageResourcePath</a></span>()</code>
<div class="block">获取该程序的安装包资源路径</div>
</td>
</tr>
<tr id="i58" class="altColor">
<td class="colFirst"><code>android.content.res.Resources</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#getResources--">getResources</a></span>()</code>
<div class="block">读取系统资源</div>
</td>
</tr>
<tr id="i59" class="rowColor">
<td class="colFirst"><code>android.content.SharedPreferences</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#getSharedPreferences-java.lang.String-int-">getSharedPreferences</a></span>(java.lang.String&nbsp;name,
                    int&nbsp;mode)</code>
<div class="block">获取SharedPreferences对象</div>
</td>
</tr>
<tr id="i60" class="altColor">
<td class="colFirst"><code>java.lang.Object</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#getSystemService-java.lang.String-">getSystemService</a></span>(java.lang.String&nbsp;name)</code>
<div class="block">按名称将句柄返回到系统级服务。</div>
</td>
</tr>
<tr id="i61" class="rowColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#getSystemServiceName-java.lang.Class-">getSystemServiceName</a></span>(java.lang.Class&lt;?&gt;&nbsp;serviceClass)</code>
<div class="block">获取由指定类表示的系统级服务的名称。</div>
</td>
</tr>
<tr id="i62" class="altColor">
<td class="colFirst"><code>android.content.res.Resources.Theme</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#getTheme--">getTheme</a></span>()</code>
<div class="block">获取主题Resources.Theme对象</div>
</td>
</tr>
<tr id="i63" class="rowColor">
<td class="colFirst"><code>android.graphics.drawable.Drawable</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#getWallpaper--">getWallpaper</a></span>()</code>
<div class="block">获取壁纸</div>
</td>
</tr>
<tr id="i64" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#getWallpaperDesiredMinimumHeight--">getWallpaperDesiredMinimumHeight</a></span>()</code>
<div class="block">获取壁纸所需的最小高度</div>
</td>
</tr>
<tr id="i65" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#getWallpaperDesiredMinimumWidth--">getWallpaperDesiredMinimumWidth</a></span>()</code>
<div class="block">获取壁纸所需的最小宽度</div>
</td>
</tr>
<tr id="i66" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#grantUriPermission-java.lang.String-android.net.Uri-int-">grantUriPermission</a></span>(java.lang.String&nbsp;toPackage,
                  android.net.Uri&nbsp;uri,
                  int&nbsp;modeFlags)</code>
<div class="block">授予访问特定Uri到另一个包的权限，无论该包是否具有访问Uri内容提供者的一般权限。</div>
</td>
</tr>
<tr id="i67" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#hashCode--">hashCode</a></span>()</code>
<div class="block">Returns a hash code value for the object.</div>
</td>
</tr>
<tr id="i68" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#isDeviceProtectedStorage--">isDeviceProtectedStorage</a></span>()</code>
<div class="block">指示此上下文的存储API是否由受设备保护的存储支持。</div>
</td>
</tr>
<tr id="i69" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#isRestricted--">isRestricted</a></span>()</code>
<div class="block">表示这种情况下是否受到限制。</div>
</td>
</tr>
<tr id="i70" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#moveDatabaseFrom-android.content.Context-java.lang.String-">moveDatabaseFrom</a></span>(android.content.Context&nbsp;sourceContext,
                java.lang.String&nbsp;name)</code>
<div class="block">将现有数据库文件从给定的源存储上下文移动到此上下文。</div>
</td>
</tr>
<tr id="i71" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#moveSharedPreferencesFrom-android.content.Context-java.lang.String-">moveSharedPreferencesFrom</a></span>(android.content.Context&nbsp;sourceContext,
                         java.lang.String&nbsp;name)</code>
<div class="block">移动SharedPreferences从sourceContext到当前Context</div>
</td>
</tr>
<tr id="i72" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#onConfigurationChanged-android.content.res.Configuration-">onConfigurationChanged</a></span>(android.content.res.Configuration&nbsp;newConfig)</code>
<div class="block">系统的配置信息发生改变时，系统会调用此方法</div>
</td>
</tr>
<tr id="i73" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#onCreate--">onCreate</a></span>()</code>
<div class="block">Called when the application is starting, before any activity, service,
 or receiver objects (excluding content providers) have been created.</div>
</td>
</tr>
<tr id="i74" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#onLowMemory--">onLowMemory</a></span>()</code>
<div class="block">该方法主要用于当前系统可用内存比较低的时候回调使用。</div>
</td>
</tr>
<tr id="i75" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#onTerminate--">onTerminate</a></span>()</code>
<div class="block">This method is for use in emulated process environments.</div>
</td>
</tr>
<tr id="i76" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#onTrimMemory-int-">onTrimMemory</a></span>(int&nbsp;level)</code>
<div class="block">系统会根据不同的内存状态来回调。</div>
</td>
</tr>
<tr id="i77" class="rowColor">
<td class="colFirst"><code>java.io.FileInputStream</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#openFileInput-java.lang.String-">openFileInput</a></span>(java.lang.String&nbsp;name)</code>
<div class="block">打开指定文件名称的输入流</div>
</td>
</tr>
<tr id="i78" class="altColor">
<td class="colFirst"><code>java.io.FileOutputStream</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#openFileOutput-java.lang.String-int-">openFileOutput</a></span>(java.lang.String&nbsp;name,
              int&nbsp;mode)</code>
<div class="block">打开指定文件名称的输出流</div>
</td>
</tr>
<tr id="i79" class="rowColor">
<td class="colFirst"><code>android.database.sqlite.SQLiteDatabase</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#openOrCreateDatabase-java.lang.String-int-android.database.sqlite.SQLiteDatabase.CursorFactory-">openOrCreateDatabase</a></span>(java.lang.String&nbsp;name,
                    int&nbsp;mode,
                    android.database.sqlite.SQLiteDatabase.CursorFactory&nbsp;factory)</code>
<div class="block">打开与此Context的应用程序包关联的新私有SQLiteDatabase。</div>
</td>
</tr>
<tr id="i80" class="altColor">
<td class="colFirst"><code>android.database.sqlite.SQLiteDatabase</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#openOrCreateDatabase-java.lang.String-int-android.database.sqlite.SQLiteDatabase.CursorFactory-android.database.DatabaseErrorHandler-">openOrCreateDatabase</a></span>(java.lang.String&nbsp;name,
                    int&nbsp;mode,
                    android.database.sqlite.SQLiteDatabase.CursorFactory&nbsp;factory,
                    android.database.DatabaseErrorHandler&nbsp;errorHandler)</code>
<div class="block">打开与此Context的应用程序包关联的新私有SQLiteDatabase。</div>
</td>
</tr>
<tr id="i81" class="rowColor">
<td class="colFirst"><code>android.graphics.drawable.Drawable</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#peekWallpaper--">peekWallpaper</a></span>()</code>
<div class="block">检索当前系统壁纸; 如果没有设置壁纸，则返回空指针。</div>
</td>
</tr>
<tr id="i82" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#registerActivityLifecycleCallbacks-android.app.Application.ActivityLifecycleCallbacks-">registerActivityLifecycleCallbacks</a></span>(android.app.Application.ActivityLifecycleCallbacks&nbsp;callback)</code>
<div class="block">注册之后应用里的所有activity的生命周期都会被监控起来。</div>
</td>
</tr>
<tr id="i83" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#registerComponentCallbacks-android.content.ComponentCallbacks-">registerComponentCallbacks</a></span>(android.content.ComponentCallbacks&nbsp;callback)</code>
<div class="block">注册组件回调</div>
</td>
</tr>
<tr id="i84" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#registerOnProvideAssistDataListener-android.app.Application.OnProvideAssistDataListener-">registerOnProvideAssistDataListener</a></span>(android.app.Application.OnProvideAssistDataListener&nbsp;callback)</code>
<div class="block">注册请求辅助监听
 当用户请求辅助时，调用此方法，以使用当前应用程序的所有上下文构建完整的ACTION_ASSIST Intent。</div>
</td>
</tr>
<tr id="i85" class="rowColor">
<td class="colFirst"><code>android.content.Intent</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#registerReceiver-android.content.BroadcastReceiver-android.content.IntentFilter-">registerReceiver</a></span>(android.content.BroadcastReceiver&nbsp;receiver,
                android.content.IntentFilter&nbsp;filter)</code>
<div class="block">注册Intent广播的接收器，在scheduler的上下文中运行。</div>
</td>
</tr>
<tr id="i86" class="altColor">
<td class="colFirst"><code>android.content.Intent</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#registerReceiver-android.content.BroadcastReceiver-android.content.IntentFilter-int-">registerReceiver</a></span>(android.content.BroadcastReceiver&nbsp;receiver,
                android.content.IntentFilter&nbsp;filter,
                int&nbsp;flags)</code>
<div class="block">注册Intent广播的接收器，在scheduler的上下文中运行。</div>
</td>
</tr>
<tr id="i87" class="rowColor">
<td class="colFirst"><code>android.content.Intent</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#registerReceiver-android.content.BroadcastReceiver-android.content.IntentFilter-java.lang.String-android.os.Handler-">registerReceiver</a></span>(android.content.BroadcastReceiver&nbsp;receiver,
                android.content.IntentFilter&nbsp;filter,
                java.lang.String&nbsp;broadcastPermission,
                android.os.Handler&nbsp;scheduler)</code>
<div class="block">注册Intent广播的接收器，在scheduler的上下文中运行。</div>
</td>
</tr>
<tr id="i88" class="altColor">
<td class="colFirst"><code>android.content.Intent</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#registerReceiver-android.content.BroadcastReceiver-android.content.IntentFilter-java.lang.String-android.os.Handler-int-">registerReceiver</a></span>(android.content.BroadcastReceiver&nbsp;receiver,
                android.content.IntentFilter&nbsp;filter,
                java.lang.String&nbsp;broadcastPermission,
                android.os.Handler&nbsp;scheduler,
                int&nbsp;flags)</code>
<div class="block">注册Intent广播的接收器，在scheduler的上下文中运行。</div>
</td>
</tr>
<tr id="i89" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#removeStickyBroadcast-android.content.Intent-">removeStickyBroadcast</a></span>(android.content.Intent&nbsp;intent)</code>
<div class="block">删除先前使用<a href="../../../com/lzf/myhfuteducn/LzfApplication.html#sendStickyBroadcast-android.content.Intent-"><code>sendStickyBroadcast(android.content.Intent)</code></a>发送的数据，这样就好像粘性广播从未发生过一样。</div>
</td>
</tr>
<tr id="i90" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#removeStickyBroadcastAsUser-android.content.Intent-android.os.UserHandle-">removeStickyBroadcastAsUser</a></span>(android.content.Intent&nbsp;intent,
                           android.os.UserHandle&nbsp;user)</code>
<div class="block">允许您移除指定广播将被发送到的用户。</div>
</td>
</tr>
<tr id="i91" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#revokeUriPermission-java.lang.String-android.net.Uri-int-">revokeUriPermission</a></span>(java.lang.String&nbsp;targetPackage,
                   android.net.Uri&nbsp;uri,
                   int&nbsp;modeFlags)</code>
<div class="block">删除访问特定内容提供程序Uri的权限，该特定内容提供程序Uri之前已添加<a href="../../../com/lzf/myhfuteducn/LzfApplication.html#grantUriPermission-java.lang.String-android.net.Uri-int-"><code>grantUriPermission(java.lang.String, android.net.Uri, int)</code></a>以用于特定目标程序包。</div>
</td>
</tr>
<tr id="i92" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#revokeUriPermission-android.net.Uri-int-">revokeUriPermission</a></span>(android.net.Uri&nbsp;uri,
                   int&nbsp;modeFlags)</code>
<div class="block">删除以前使用<a href="../../../com/lzf/myhfuteducn/LzfApplication.html#grantUriPermission-java.lang.String-android.net.Uri-int-"><code>grantUriPermission(java.lang.String, android.net.Uri, int)</code></a>或任何其他机制添加的特定内容提供商Uri的所有权限。</div>
</td>
</tr>
<tr id="i93" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#sendBroadcast-android.content.Intent-">sendBroadcast</a></span>(android.content.Intent&nbsp;intent)</code>
<div class="block">将给定意图广播给所有感兴趣的BroadcastReceivers，允许强制执行可选的必需权限。</div>
</td>
</tr>
<tr id="i94" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#sendBroadcast-android.content.Intent-java.lang.String-">sendBroadcast</a></span>(android.content.Intent&nbsp;intent,
             java.lang.String&nbsp;receiverPermission)</code>
<div class="block">将给定意图广播给所有感兴趣的BroadcastReceivers，允许强制执行可选的必需权限。</div>
</td>
</tr>
<tr id="i95" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#sendBroadcastAsUser-android.content.Intent-android.os.UserHandle-">sendBroadcastAsUser</a></span>(android.content.Intent&nbsp;intent,
                   android.os.UserHandle&nbsp;user)</code>
<div class="block">允许您指定广播将被发送到的用户。</div>
</td>
</tr>
<tr id="i96" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#sendBroadcastAsUser-android.content.Intent-android.os.UserHandle-java.lang.String-">sendBroadcastAsUser</a></span>(android.content.Intent&nbsp;intent,
                   android.os.UserHandle&nbsp;user,
                   java.lang.String&nbsp;receiverPermission)</code>
<div class="block">允许您指定广播将被发送到的用户。</div>
</td>
</tr>
<tr id="i97" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#sendOrderedBroadcast-android.content.Intent-java.lang.String-">sendOrderedBroadcast</a></span>(android.content.Intent&nbsp;intent,
                    java.lang.String&nbsp;receiverPermission)</code>
<div class="block">允许您从广播中接收数据。</div>
</td>
</tr>
<tr id="i98" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#sendOrderedBroadcast-android.content.Intent-java.lang.String-android.content.BroadcastReceiver-android.os.Handler-int-java.lang.String-android.os.Bundle-">sendOrderedBroadcast</a></span>(android.content.Intent&nbsp;intent,
                    java.lang.String&nbsp;receiverPermission,
                    android.content.BroadcastReceiver&nbsp;resultReceiver,
                    android.os.Handler&nbsp;scheduler,
                    int&nbsp;initialCode,
                    java.lang.String&nbsp;initialData,
                    android.os.Bundle&nbsp;initialExtras)</code>
<div class="block">允许您从广播中接收数据。</div>
</td>
</tr>
<tr id="i99" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#sendOrderedBroadcastAsUser-android.content.Intent-android.os.UserHandle-java.lang.String-android.content.BroadcastReceiver-android.os.Handler-int-java.lang.String-android.os.Bundle-">sendOrderedBroadcastAsUser</a></span>(android.content.Intent&nbsp;intent,
                          android.os.UserHandle&nbsp;user,
                          java.lang.String&nbsp;receiverPermission,
                          android.content.BroadcastReceiver&nbsp;resultReceiver,
                          android.os.Handler&nbsp;scheduler,
                          int&nbsp;initialCode,
                          java.lang.String&nbsp;initialData,
                          android.os.Bundle&nbsp;initialExtras)</code>
<div class="block">允许您指定广播将被发送到的用户。</div>
</td>
</tr>
<tr id="i100" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#sendStickyBroadcast-android.content.Intent-">sendStickyBroadcast</a></span>(android.content.Intent&nbsp;intent)</code>
<div class="block">执行“粘性”的<code>#sendBroadcast（Intent）</code>，这意味着您发送的意图在广播完成后保持不变，以便其他人可以通过 <a href="../../../com/lzf/myhfuteducn/LzfApplication.html#registerReceiver-android.content.BroadcastReceiver-android.content.IntentFilter-"><code>registerReceiver(BroadcastReceiver, IntentFilter)</code></a>的返回值快速检索该数据。</div>
</td>
</tr>
<tr id="i101" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#sendStickyBroadcastAsUser-android.content.Intent-android.os.UserHandle-">sendStickyBroadcastAsUser</a></span>(android.content.Intent&nbsp;intent,
                         android.os.UserHandle&nbsp;user)</code>
<div class="block">允许您指定广播将被发送到的用户。</div>
</td>
</tr>
<tr id="i102" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#sendStickyOrderedBroadcast-android.content.Intent-android.content.BroadcastReceiver-android.os.Handler-int-java.lang.String-android.os.Bundle-">sendStickyOrderedBroadcast</a></span>(android.content.Intent&nbsp;intent,
                          android.content.BroadcastReceiver&nbsp;resultReceiver,
                          android.os.Handler&nbsp;scheduler,
                          int&nbsp;initialCode,
                          java.lang.String&nbsp;initialData,
                          android.os.Bundle&nbsp;initialExtras)</code>
<div class="block">允许您从广播中接收数据。</div>
</td>
</tr>
<tr id="i103" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#sendStickyOrderedBroadcastAsUser-android.content.Intent-android.os.UserHandle-android.content.BroadcastReceiver-android.os.Handler-int-java.lang.String-android.os.Bundle-">sendStickyOrderedBroadcastAsUser</a></span>(android.content.Intent&nbsp;intent,
                                android.os.UserHandle&nbsp;user,
                                android.content.BroadcastReceiver&nbsp;resultReceiver,
                                android.os.Handler&nbsp;scheduler,
                                int&nbsp;initialCode,
                                java.lang.String&nbsp;initialData,
                                android.os.Bundle&nbsp;initialExtras)</code>
<div class="block">允许您指定广播将被发送到的用户。</div>
</td>
</tr>
<tr id="i104" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#setTheme-int-">setTheme</a></span>(int&nbsp;resid)</code>
<div class="block">设置主题</div>
</td>
</tr>
<tr id="i105" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#setWallpaper-android.graphics.Bitmap-">setWallpaper</a></span>(android.graphics.Bitmap&nbsp;bitmap)</code>
<div class="block">设置壁纸</div>
</td>
</tr>
<tr id="i106" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#setWallpaper-java.io.InputStream-">setWallpaper</a></span>(java.io.InputStream&nbsp;data)</code>
<div class="block">设置壁纸</div>
</td>
</tr>
<tr id="i107" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#startActivities-android.content.Intent:A-">startActivities</a></span>(android.content.Intent[]&nbsp;intents)</code>
<div class="block">开启一系列新的Activity</div>
</td>
</tr>
<tr id="i108" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#startActivities-android.content.Intent:A-android.os.Bundle-">startActivities</a></span>(android.content.Intent[]&nbsp;intents,
               android.os.Bundle&nbsp;options)</code>
<div class="block">开启一系列新的Activity</div>
</td>
</tr>
<tr id="i109" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#startActivity-android.content.Intent-">startActivity</a></span>(android.content.Intent&nbsp;intent)</code>
<div class="block">开启一个新的Activity</div>
</td>
</tr>
<tr id="i110" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#startActivity-android.content.Intent-android.os.Bundle-">startActivity</a></span>(android.content.Intent&nbsp;intent,
             android.os.Bundle&nbsp;options)</code>
<div class="block">开启一个新的Activity</div>
</td>
</tr>
<tr id="i111" class="rowColor">
<td class="colFirst"><code>android.content.ComponentName</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#startForegroundService-android.content.Intent-">startForegroundService</a></span>(android.content.Intent&nbsp;service)</code>
<div class="block">类似于<code>#startService（Intent）</code>，但隐含的承诺是服务将调用<code>）</code>一旦它开始运行。</div>
</td>
</tr>
<tr id="i112" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#startInstrumentation-android.content.ComponentName-java.lang.String-android.os.Bundle-">startInstrumentation</a></span>(android.content.ComponentName&nbsp;className,
                    java.lang.String&nbsp;profileFile,
                    android.os.Bundle&nbsp;arguments)</code>
<div class="block">开始执行<code>Instrumentation</code>类。</div>
</td>
</tr>
<tr id="i113" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#startIntentSender-android.content.IntentSender-android.content.Intent-int-int-int-">startIntentSender</a></span>(android.content.IntentSender&nbsp;intent,
                 android.content.Intent&nbsp;fillInIntent,
                 int&nbsp;flagsMask,
                 int&nbsp;flagsValues,
                 int&nbsp;extraFlags)</code>
<div class="block">像<code>#startActivity（Intent，Bundle）</code>一样，但是要开始使用IntentSender。</div>
</td>
</tr>
<tr id="i114" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#startIntentSender-android.content.IntentSender-android.content.Intent-int-int-int-android.os.Bundle-">startIntentSender</a></span>(android.content.IntentSender&nbsp;intent,
                 android.content.Intent&nbsp;fillInIntent,
                 int&nbsp;flagsMask,
                 int&nbsp;flagsValues,
                 int&nbsp;extraFlags,
                 android.os.Bundle&nbsp;options)</code>
<div class="block">像<code>#startActivity（Intent，Bundle）</code>一样，但是要开始使用IntentSender。</div>
</td>
</tr>
<tr id="i115" class="rowColor">
<td class="colFirst"><code>android.content.ComponentName</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#startService-android.content.Intent-">startService</a></span>(android.content.Intent&nbsp;service)</code>
<div class="block">请求启动给定的应用程序服务。</div>
</td>
</tr>
<tr id="i116" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#stopService-android.content.Intent-">stopService</a></span>(android.content.Intent&nbsp;name)</code>
<div class="block">请求停止给定的应用程序服务。</div>
</td>
</tr>
<tr id="i117" class="rowColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#toString--">toString</a></span>()</code>
<div class="block">Returns a string representation of the object.</div>
</td>
</tr>
<tr id="i118" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#unbindService-android.content.ServiceConnection-">unbindService</a></span>(android.content.ServiceConnection&nbsp;conn)</code>
<div class="block">断开与应用程序服务的连接。</div>
</td>
</tr>
<tr id="i119" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#unregisterActivityLifecycleCallbacks-android.app.Application.ActivityLifecycleCallbacks-">unregisterActivityLifecycleCallbacks</a></span>(android.app.Application.ActivityLifecycleCallbacks&nbsp;callback)</code>
<div class="block">取消注册监控所有activity的生命周期回调。</div>
</td>
</tr>
<tr id="i120" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#unregisterComponentCallbacks-android.content.ComponentCallbacks-">unregisterComponentCallbacks</a></span>(android.content.ComponentCallbacks&nbsp;callback)</code>
<div class="block">删除组件回调</div>
</td>
</tr>
<tr id="i121" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#unregisterOnProvideAssistDataListener-android.app.Application.OnProvideAssistDataListener-">unregisterOnProvideAssistDataListener</a></span>(android.app.Application.OnProvideAssistDataListener&nbsp;callback)</code>
<div class="block">删除请求辅助监听</div>
</td>
</tr>
<tr id="i122" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#unregisterReceiver-android.content.BroadcastReceiver-">unregisterReceiver</a></span>(android.content.BroadcastReceiver&nbsp;receiver)</code>
<div class="block">取消注册以前注册的BroadcastReceiver。</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.android.app.Application">
<!--   -->
</a>
<h3>从类继承的方法&nbsp;android.app.Application</h3>
<code>getProcessName</code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.android.content.ContextWrapper">
<!--   -->
</a>
<h3>从类继承的方法&nbsp;android.content.ContextWrapper</h3>
<code>getMainExecutor</code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.android.content.Context">
<!--   -->
</a>
<h3>从类继承的方法&nbsp;android.content.Context</h3>
<code>getColor, getColorStateList, getDrawable, getString, getString, getSystemService, getText, obtainStyledAttributes, obtainStyledAttributes, obtainStyledAttributes, obtainStyledAttributes</code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>从类继承的方法&nbsp;java.lang.Object</h3>
<code>getClass, notify, notifyAll, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.detail">
<!--   -->
</a>
<h3>构造器详细资料</h3>
<a name="LzfApplication--">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>LzfApplication</h4>
<pre>public&nbsp;LzfApplication()</pre>
<div class="block">无参构造方法</div>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>方法详细资料</h3>
<a name="getContext--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getContext</h4>
<pre>public static&nbsp;android.content.Context&nbsp;getContext()</pre>
<div class="block">获取环境/上下文实例</div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>环境/上下文</dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><code>Context</code></dd>
</dl>
</li>
</ul>
<a name="hashCode--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hashCode</h4>
<pre>public&nbsp;int&nbsp;hashCode()</pre>
<div class="block">Returns a hash code value for the object. This method is
 supported for the benefit of hash tables such as those provided by
 <code>HashMap</code>.
 <p>
 The general contract of <code>hashCode</code> is:
 <ul>
 <li>Whenever it is invoked on the same object more than once during
 an execution of a Java application, the <code>hashCode</code> method
 must consistently return the same integer, provided no information
 used in <code>equals</code> comparisons on the object is modified.
 This integer need not remain consistent from one execution of an
 application to another execution of the same application.
 <li>If two objects are equal according to the <code>equals(Object)</code>
 method, then calling the <code>hashCode</code> method on each of
 the two objects must produce the same integer result.
 <li>It is <em>not</em> required that if two objects are unequal
 according to the <code>Object.equals(Object)</code>
 method, then calling the <code>hashCode</code> method on each of the
 two objects must produce distinct integer results.  However, the
 programmer should be aware that producing distinct integer results
 for unequal objects may improve the performance of hash tables.
 </ul>
 <p>
 As much as is reasonably practical, the hashCode method defined by
 class <code>Object</code> does return distinct integers for distinct
 objects. (This is typically implemented by converting the internal
 address of the object into an integer, but this implementation
 technique is not required by the
 Java&trade; programming language.)</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>hashCode</code>&nbsp;在类中&nbsp;<code>java.lang.Object</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a hash code value for this object.</dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><code>Object.equals(Object)</code>, 
<code>System.identityHashCode(java.lang.Object)</code></dd>
</dl>
</li>
</ul>
<a name="equals-java.lang.Object-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>equals</h4>
<pre>public&nbsp;boolean&nbsp;equals(java.lang.Object&nbsp;obj)</pre>
<div class="block">Indicates whether some other object is "equal to" this one.
 <p>
 The <code>equals</code> method implements an equivalence relation
 on non-null object references:
 <ul>
 <li>It is <i>reflexive</i>: for any non-null reference value
 <code>x</code>, <code>x.equals(x)</code> should return
 <code>true</code>.
 <li>It is <i>symmetric</i>: for any non-null reference values
 <code>x</code> and <code>y</code>, <code>x.equals(y)</code>
 should return <code>true</code> if and only if
 <code>y.equals(x)</code> returns <code>true</code>.
 <li>It is <i>transitive</i>: for any non-null reference values
 <code>x</code>, <code>y</code>, and <code>z</code>, if
 <code>x.equals(y)</code> returns <code>true</code> and
 <code>y.equals(z)</code> returns <code>true</code>, then
 <code>x.equals(z)</code> should return <code>true</code>.
 <li>It is <i>consistent</i>: for any non-null reference values
 <code>x</code> and <code>y</code>, multiple invocations of
 <code>x.equals(y)</code> consistently return <code>true</code>
 or consistently return <code>false</code>, provided no
 information used in <code>equals</code> comparisons on the
 objects is modified.
 <li>For any non-null reference value <code>x</code>,
 <code>x.equals(null)</code> should return <code>false</code>.
 </ul>
 <p>
 The <code>equals</code> method for class <code>Object</code> implements
 the most discriminating possible equivalence relation on objects;
 that is, for any non-null reference values <code>x</code> and
 <code>y</code>, this method returns <code>true</code> if and only
 if <code>x</code> and <code>y</code> refer to the same object
 (<code>x == y</code> has the value <code>true</code>).
 <p>
 Note that it is generally necessary to override the <code>hashCode</code>
 method whenever this method is overridden, so as to maintain the
 general contract for the <code>hashCode</code> method, which states
 that equal objects must have equal hash codes.</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>equals</code>&nbsp;在类中&nbsp;<code>java.lang.Object</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>obj</code> - the reference object with which to compare.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd><code>true</code> if this object is the same as the obj
 argument; <code>false</code> otherwise.</dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../com/lzf/myhfuteducn/LzfApplication.html#hashCode--"><code>hashCode()</code></a>, 
<code>HashMap</code></dd>
</dl>
</li>
</ul>
<a name="clone--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clone</h4>
<pre>protected&nbsp;java.lang.Object&nbsp;clone()
                          throws java.lang.CloneNotSupportedException</pre>
<div class="block">Creates and returns a copy of this object.  The precise meaning
 of "copy" may depend on the class of the object. The general
 intent is that, for any object <code>x</code>, the expression:
 <blockquote>
 <pre>
 x.clone() != x</pre></blockquote>
 will be true, and that the expression:
 <blockquote>
 <pre>
 x.clone().getClass() == x.getClass()</pre></blockquote>
 will be <code>true</code>, but these are not absolute requirements.
 While it is typically the case that:
 <blockquote>
 <pre>
 x.clone().equals(x)</pre></blockquote>
 will be <code>true</code>, this is not an absolute requirement.

 By convention, the returned object should be obtained by calling
 <code>super.clone</code>.  If a class and all of its superclasses (except
 <code>Object</code>) obey this convention, it will be the case that
 <code>x.clone().getClass() == x.getClass()</code>.

 By convention, the object returned by this method should be independent
 of this object (which is being cloned).  To achieve this independence,
 it may be necessary to modify one or more fields of the object returned
 by <code>super.clone</code> before returning it.  Typically, this means
 copying any mutable objects that comprise the internal "deep structure"
 of the object being cloned and replacing the references to these
 objects with references to the copies.  If a class contains only
 primitive fields or references to immutable objects, then it is usually
 the case that no fields in the object returned by <code>super.clone</code>
 need to be modified.

 The method <code>clone</code> for class <code>Object</code> performs a
 specific cloning operation. First, if the class of this object does
 not implement the interface <code>Cloneable</code>, then a
 <code>CloneNotSupportedException</code> is thrown. Note that all arrays
 are considered to implement the interface <code>Cloneable</code> and that
 the return type of the <code>clone</code> method of an array type <code>T[]</code>
 is <code>T[]</code> where T is any reference or primitive type.
 Otherwise, this method creates a new instance of the class of this
 object and initializes all its fields with exactly the contents of
 the corresponding fields of this object, as if by assignment; the
 contents of the fields are not themselves cloned. Thus, this method
 performs a "shallow copy" of this object, not a "deep copy" operation.

 The class <code>Object</code> does not itself implement the interface
 <code>Cloneable</code>, so calling the <code>clone</code> method on an object
 whose class is <code>Object</code> will result in throwing an
 exception at run time.</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>clone</code>&nbsp;在类中&nbsp;<code>java.lang.Object</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a clone of this instance.</dd>
<dt><span class="throwsLabel">抛出:</span></dt>
<dd><code>java.lang.CloneNotSupportedException</code> - if the object's class does not
                                    support the <code>Cloneable</code> interface. Subclasses
                                    that override the <code>clone</code> method can also
                                    throw this exception to indicate that an instance cannot
                                    be cloned.</dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><code>Cloneable</code></dd>
</dl>
</li>
</ul>
<a name="toString--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toString</h4>
<pre>public&nbsp;java.lang.String&nbsp;toString()</pre>
<div class="block">Returns a string representation of the object. In general, the
 <code>toString</code> method returns a string that
 "textually represents" this object. The result should
 be a concise but informative representation that is easy for a
 person to read.
 It is recommended that all subclasses override this method.
 <p>
 The <code>toString</code> method for class <code>Object</code>
 returns a string consisting of the name of the class of which the
 object is an instance, the at-sign character `<code>@</code>', and
 the unsigned hexadecimal representation of the hash code of the
 object. In other words, this method returns a string equal to the
 value of:
 <blockquote>
 <pre>
 getClass().getName() + '@' + Integer.toHexString(hashCode())
 </pre></blockquote></div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>toString</code>&nbsp;在类中&nbsp;<code>java.lang.Object</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a string representation of the object.</dd>
</dl>
</li>
</ul>
<a name="finalize--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>finalize</h4>
<pre>protected&nbsp;void&nbsp;finalize()
                 throws java.lang.Throwable</pre>
<div class="block">Called by the garbage collector on an object when garbage collection
 determines that there are no more references to the object.
 A subclass overrides the <code>finalize</code> method to dispose of
 system resources or to perform other cleanup.
 <p>
 The general contract of <code>finalize</code> is that it is invoked
 if and when the Java&trade; virtual
 machine has determined that there is no longer any
 means by which this object can be accessed by any thread that has
 not yet died, except as a result of an action taken by the
 finalization of some other object or class which is ready to be
 finalized. The <code>finalize</code> method may take any action, including
 making this object available again to other threads; the usual purpose
 of <code>finalize</code>, however, is to perform cleanup actions before
 the object is irrevocably discarded. For example, the finalize method
 for an object that represents an input/output connection might perform
 explicit I/O transactions to break the connection before the object is
 permanently discarded.
 <p>
 The <code>finalize</code> method of class <code>Object</code> performs no
 special action; it simply returns normally. Subclasses of
 <code>Object</code> may override this definition.
 <p>
 The Java programming language does not guarantee which thread will
 invoke the <code>finalize</code> method for any given object. It is
 guaranteed, however, that the thread that invokes finalize will not
 be holding any user-visible synchronization locks when finalize is
 invoked. If an uncaught exception is thrown by the finalize method,
 the exception is ignored and finalization of that object terminates.
 <p>
 After the <code>finalize</code> method has been invoked for an object, no
 further action is taken until the Java virtual machine has again
 determined that there is no longer any means by which this object can
 be accessed by any thread that has not yet died, including possible
 actions by other objects or classes which are ready to be finalized,
 at which point the object may be discarded.
 <p>
 The <code>finalize</code> method is never invoked more than once by a Java
 virtual machine for any given object.
 <p>
 Any exception thrown by the <code>finalize</code> method causes
 the finalization of this object to be halted, but is otherwise
 ignored.</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>finalize</code>&nbsp;在类中&nbsp;<code>java.lang.Object</code></dd>
<dt><span class="throwsLabel">抛出:</span></dt>
<dd><code>java.lang.Throwable</code> - the <code>Exception</code> raised by this method</dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><code>WeakReference</code>, 
<code>PhantomReference</code></dd>
</dl>
</li>
</ul>
<a name="onCreate--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onCreate</h4>
<pre>public&nbsp;void&nbsp;onCreate()</pre>
<div class="block">Called when the application is starting, before any activity, service,
 or receiver objects (excluding content providers) have been created.
 Implementations should be as quick as possible (for example using
 lazy initialization of state) since the time spent in this function
 directly impacts the performance of starting the first activity,
 service, or receiver in a process.
 If you override this method, be sure to call super.onCreate().</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>onCreate</code>&nbsp;在类中&nbsp;<code>android.app.Application</code></dd>
</dl>
</li>
</ul>
<a name="onTerminate--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onTerminate</h4>
<pre>public&nbsp;void&nbsp;onTerminate()</pre>
<div class="block">This method is for use in emulated process environments.  It will
 never be called on a production Android device, where processes are
 removed by simply killing them; no user code (including this callback)
 is executed when doing so.</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>onTerminate</code>&nbsp;在类中&nbsp;<code>android.app.Application</code></dd>
</dl>
</li>
</ul>
<a name="onConfigurationChanged-android.content.res.Configuration-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onConfigurationChanged</h4>
<pre>public&nbsp;void&nbsp;onConfigurationChanged(android.content.res.Configuration&nbsp;newConfig)</pre>
<div class="block">系统的配置信息发生改变时，系统会调用此方法</div>
<dl>
<dt><span class="overrideSpecifyLabel">指定者:</span></dt>
<dd><code>onConfigurationChanged</code>&nbsp;在接口中&nbsp;<code>android.content.ComponentCallbacks</code></dd>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>onConfigurationChanged</code>&nbsp;在类中&nbsp;<code>android.app.Application</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>newConfig</code> - 新的设备配置信息</dd>
</dl>
</li>
</ul>
<a name="onLowMemory--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onLowMemory</h4>
<pre>public&nbsp;void&nbsp;onLowMemory()</pre>
<div class="block">该方法主要用于当前系统可用内存比较低的时候回调使用。
 OnLowMemory被回调时，已经没有后台进程；</div>
<dl>
<dt><span class="overrideSpecifyLabel">指定者:</span></dt>
<dd><code>onLowMemory</code>&nbsp;在接口中&nbsp;<code>android.content.ComponentCallbacks</code></dd>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>onLowMemory</code>&nbsp;在类中&nbsp;<code>android.app.Application</code></dd>
</dl>
</li>
</ul>
<a name="onTrimMemory-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onTrimMemory</h4>
<pre>public&nbsp;void&nbsp;onTrimMemory(int&nbsp;level)</pre>
<div class="block">系统会根据不同的内存状态来回调。根据不同的内存状态，来响应不同的内存释放策略。\
 onTrimMemory被回调时，还有后台进程。</div>
<dl>
<dt><span class="overrideSpecifyLabel">指定者:</span></dt>
<dd><code>onTrimMemory</code>&nbsp;在接口中&nbsp;<code>android.content.ComponentCallbacks2</code></dd>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>onTrimMemory</code>&nbsp;在类中&nbsp;<code>android.app.Application</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>level</code> - 代表不同的内存状态
              TRIM_MEMORY_COMPLETE：内存不足，并且该进程在后台进程列表最后一个，马上就要被清理
              TRIM_MEMORY_MODERATE：内存不足，并且该进程在后台进程列表的中部。
              TRIM_MEMORY_BACKGROUND：内存不足，并且该进程是后台进程。
              TRIM_MEMORY_UI_HIDDEN：内存不足，并且该进程的UI已经不可见了。
              TRIM_MEMORY_RUNNING_CRITICAL：内存不足(后台进程不足3个)，并且该进程优先级比较高，需要清理内存
              TRIM_MEMORY_RUNNING_LOW：内存不足(后台进程不足5个)，并且该进程优先级比较高，需要清理内存
              TRIM_MEMORY_RUNNING_MODERATE：内存不足(后台进程超过5个)，并且该进程优先级比较高，需要清理内存</dd>
</dl>
</li>
</ul>
<a name="registerComponentCallbacks-android.content.ComponentCallbacks-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>registerComponentCallbacks</h4>
<pre>public&nbsp;void&nbsp;registerComponentCallbacks(android.content.ComponentCallbacks&nbsp;callback)</pre>
<div class="block">注册组件回调</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>registerComponentCallbacks</code>&nbsp;在类中&nbsp;<code>android.app.Application</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>callback</code> - 所有应用程序组件通用的回调API集</dd>
</dl>
</li>
</ul>
<a name="unregisterComponentCallbacks-android.content.ComponentCallbacks-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>unregisterComponentCallbacks</h4>
<pre>public&nbsp;void&nbsp;unregisterComponentCallbacks(android.content.ComponentCallbacks&nbsp;callback)</pre>
<div class="block">删除组件回调</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>unregisterComponentCallbacks</code>&nbsp;在类中&nbsp;<code>android.app.Application</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>callback</code> - 所有应用程序组件通用的回调API集</dd>
</dl>
</li>
</ul>
<a name="registerActivityLifecycleCallbacks-android.app.Application.ActivityLifecycleCallbacks-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>registerActivityLifecycleCallbacks</h4>
<pre>public&nbsp;void&nbsp;registerActivityLifecycleCallbacks(android.app.Application.ActivityLifecycleCallbacks&nbsp;callback)</pre>
<div class="block">注册之后应用里的所有activity的生命周期都会被监控起来。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>registerActivityLifecycleCallbacks</code>&nbsp;在类中&nbsp;<code>android.app.Application</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>callback</code> - 用于监听应用中所有Activity的运行情况</dd>
</dl>
</li>
</ul>
<a name="unregisterActivityLifecycleCallbacks-android.app.Application.ActivityLifecycleCallbacks-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>unregisterActivityLifecycleCallbacks</h4>
<pre>public&nbsp;void&nbsp;unregisterActivityLifecycleCallbacks(android.app.Application.ActivityLifecycleCallbacks&nbsp;callback)</pre>
<div class="block">取消注册监控所有activity的生命周期回调。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>unregisterActivityLifecycleCallbacks</code>&nbsp;在类中&nbsp;<code>android.app.Application</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>callback</code> - 用于监听应用中所有Activity的运行情况</dd>
</dl>
</li>
</ul>
<a name="registerOnProvideAssistDataListener-android.app.Application.OnProvideAssistDataListener-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>registerOnProvideAssistDataListener</h4>
<pre>public&nbsp;void&nbsp;registerOnProvideAssistDataListener(android.app.Application.OnProvideAssistDataListener&nbsp;callback)</pre>
<div class="block">注册请求辅助监听
 当用户请求辅助时，调用此方法，以使用当前应用程序的所有上下文构建完整的ACTION_ASSIST Intent。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>registerOnProvideAssistDataListener</code>&nbsp;在类中&nbsp;<code>android.app.Application</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>callback</code> - 当用户请求辅助时回调</dd>
</dl>
</li>
</ul>
<a name="unregisterOnProvideAssistDataListener-android.app.Application.OnProvideAssistDataListener-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>unregisterOnProvideAssistDataListener</h4>
<pre>public&nbsp;void&nbsp;unregisterOnProvideAssistDataListener(android.app.Application.OnProvideAssistDataListener&nbsp;callback)</pre>
<div class="block">删除请求辅助监听</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>unregisterOnProvideAssistDataListener</code>&nbsp;在类中&nbsp;<code>android.app.Application</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>callback</code> - 当用户删除请求辅助时回调</dd>
</dl>
</li>
</ul>
<a name="attachBaseContext-android.content.Context-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>attachBaseContext</h4>
<pre>protected&nbsp;void&nbsp;attachBaseContext(android.content.Context&nbsp;base)</pre>
<div class="block">Set the base context for this ContextWrapper.  All calls will then be
 delegated to the base context.  Throws
 IllegalStateException if a base context has already been set.</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>attachBaseContext</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>base</code> - The new base context for this wrapper.</dd>
</dl>
</li>
</ul>
<a name="getBaseContext--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getBaseContext</h4>
<pre>public&nbsp;android.content.Context&nbsp;getBaseContext()</pre>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>getBaseContext</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>the base context as set by the constructor or setBaseContext</dd>
</dl>
</li>
</ul>
<a name="getAssets--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getAssets</h4>
<pre>public&nbsp;android.content.res.AssetManager&nbsp;getAssets()</pre>
<div class="block">assets文件夹里面的文件都是保持原始的文件格式，需要用AssetManager以字节流的形式读取文件。
 获取AssetManager引用。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>getAssets</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>AssetManager引用。</dd>
</dl>
</li>
</ul>
<a name="getResources--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getResources</h4>
<pre>public&nbsp;android.content.res.Resources&nbsp;getResources()</pre>
<div class="block">读取系统资源</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>getResources</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>系统资源</dd>
</dl>
</li>
</ul>
<a name="getPackageManager--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getPackageManager</h4>
<pre>public&nbsp;android.content.pm.PackageManager&nbsp;getPackageManager()</pre>
<div class="block">获得一个PackageManger对象：用于检索与当前安装在设备上的应用程序包相关的各种信息的类。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>getPackageManager</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>PackageManger对象：用于检索与当前安装在设备上的应用程序包相关的各种信息的类。</dd>
</dl>
</li>
</ul>
<a name="getContentResolver--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getContentResolver</h4>
<pre>public&nbsp;android.content.ContentResolver&nbsp;getContentResolver()</pre>
<div class="block">获取ContentResolver对象：此类为应用程序提供对内容模型的访问权限。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>getContentResolver</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>ContentResolver对象：此类为应用程序提供对内容模型的访问权限。</dd>
</dl>
</li>
</ul>
<a name="getMainLooper--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMainLooper</h4>
<pre>public&nbsp;android.os.Looper&nbsp;getMainLooper()</pre>
<div class="block">获取Looper对象：用于为线程运行消息循环的类。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>getMainLooper</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>Looper对象：用于为线程运行消息循环的类。</dd>
</dl>
</li>
</ul>
<a name="getApplicationContext--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getApplicationContext</h4>
<pre>public&nbsp;android.content.Context&nbsp;getApplicationContext()</pre>
<div class="block">获取应用的环境/上下文</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>getApplicationContext</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>应用的环境/上下文</dd>
</dl>
</li>
</ul>
<a name="setTheme-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setTheme</h4>
<pre>public&nbsp;void&nbsp;setTheme(int&nbsp;resid)</pre>
<div class="block">设置主题</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>setTheme</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>resid</code> - 主题的资源ID</dd>
</dl>
</li>
</ul>
<a name="getTheme--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getTheme</h4>
<pre>public&nbsp;android.content.res.Resources.Theme&nbsp;getTheme()</pre>
<div class="block">获取主题Resources.Theme对象</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>getTheme</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>Resources.Theme对象：此类包含特定主题的当前属性值。</dd>
</dl>
</li>
</ul>
<a name="getClassLoader--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getClassLoader</h4>
<pre>public&nbsp;java.lang.ClassLoader&nbsp;getClassLoader()</pre>
<div class="block">获取用于启动主应用程序的类装入器。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>getClassLoader</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>返回用于启动主应用程序的类装入器。</dd>
</dl>
</li>
</ul>
<a name="getPackageName--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getPackageName</h4>
<pre>public&nbsp;java.lang.String&nbsp;getPackageName()</pre>
<div class="block">获取包名</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>getPackageName</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>包名</dd>
</dl>
</li>
</ul>
<a name="getApplicationInfo--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getApplicationInfo</h4>
<pre>public&nbsp;android.content.pm.ApplicationInfo&nbsp;getApplicationInfo()</pre>
<div class="block">获取ApplicationInfo对象：可以检索有关特定应用程序的信息。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>getApplicationInfo</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>ApplicationInfo对象：可以检索有关特定应用程序的信息。</dd>
</dl>
</li>
</ul>
<a name="getPackageResourcePath--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getPackageResourcePath</h4>
<pre>public&nbsp;java.lang.String&nbsp;getPackageResourcePath()</pre>
<div class="block">获取该程序的安装包资源路径</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>getPackageResourcePath</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>获取该程序的安装包资源路径</dd>
</dl>
</li>
</ul>
<a name="getPackageCodePath--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getPackageCodePath</h4>
<pre>public&nbsp;java.lang.String&nbsp;getPackageCodePath()</pre>
<div class="block">获取该程序的安装包代码路径</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>getPackageCodePath</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>该程序的安装包代码路径</dd>
</dl>
</li>
</ul>
<a name="getSharedPreferences-java.lang.String-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getSharedPreferences</h4>
<pre>public&nbsp;android.content.SharedPreferences&nbsp;getSharedPreferences(java.lang.String&nbsp;name,
                                                              int&nbsp;mode)</pre>
<div class="block">获取SharedPreferences对象</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>getSharedPreferences</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>name</code> - 配置文件名(自定义)，当这个文件不存在时，直接创建，如果已经存在，则直接使用。
             （如果想要与本应用程序的其他组件共享此配置文件，可以用这个名字来检索到这个配置文件，在这里要特别注意，因为在Android中已经确定了SharedPreferences是以xml形式保存，所以，在填写文件名参数时，不要给定“.xml”后缀，android会自动添加。只要直接写上文件名即可。它会直接被保存在/data/data/<package name>/shared_prefs路径下，它是采用键值对的形式保存参数。当你需要获得某个参数值时，按照参数的键索引即可）。</dd>
<dd><code>mode</code> - 操作模式，默认的模式为MODE_PRIVATE（代表该文件是私有数据，只能被应用本身访问，写入的内容会覆盖原文件的内容）。
             还可以使用MODE_APPEND（文件存在，直接在后面追加内容；不存在则新建）、MODE_WORLD_READABLE（当前文件可以被其他应用读取）和MODE_WORLD_WRITEABLE（当前文件可以被其他应用写入）</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>SharedPreferences对象</dd>
</dl>
</li>
</ul>
<a name="moveSharedPreferencesFrom-android.content.Context-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>moveSharedPreferencesFrom</h4>
<pre>public&nbsp;boolean&nbsp;moveSharedPreferencesFrom(android.content.Context&nbsp;sourceContext,
                                         java.lang.String&nbsp;name)</pre>
<div class="block">移动SharedPreferences从sourceContext到当前Context</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>moveSharedPreferencesFrom</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>sourceContext</code> - 原文环境/上下文</dd>
<dd><code>name</code> - SharedPreferences配置文件名(自定义)</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>是否移动成功（true：移动成功；否则：false）</dd>
</dl>
</li>
</ul>
<a name="deleteSharedPreferences-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>deleteSharedPreferences</h4>
<pre>public&nbsp;boolean&nbsp;deleteSharedPreferences(java.lang.String&nbsp;name)</pre>
<div class="block">删除配置文件名(自定义)为name的SharedPreferences</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>deleteSharedPreferences</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>name</code> - 配置文件名(自定义)</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>是否删除成功（true：删除成功；否则：false）</dd>
</dl>
</li>
</ul>
<a name="openFileInput-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>openFileInput</h4>
<pre>public&nbsp;java.io.FileInputStream&nbsp;openFileInput(java.lang.String&nbsp;name)
                                      throws java.io.FileNotFoundException</pre>
<div class="block">打开指定文件名称的输入流</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>openFileInput</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>name</code> - 指定文件的名称</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>文件输入流</dd>
<dt><span class="throwsLabel">抛出:</span></dt>
<dd><code>java.io.FileNotFoundException</code> - 文件未发现异常</dd>
</dl>
</li>
</ul>
<a name="openFileOutput-java.lang.String-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>openFileOutput</h4>
<pre>public&nbsp;java.io.FileOutputStream&nbsp;openFileOutput(java.lang.String&nbsp;name,
                                               int&nbsp;mode)
                                        throws java.io.FileNotFoundException</pre>
<div class="block">打开指定文件名称的输出流</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>openFileOutput</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>name</code> - 指定文件的名称</dd>
<dd><code>mode</code> - 操作模式，默认的模式为MODE_PRIVATE（代表该文件是私有数据，只能被应用本身访问，写入的内容会覆盖原文件的内容）。
             还可以使用MODE_APPEND（文件存在，直接在后面追加内容；不存在则新建）、MODE_WORLD_READABLE（当前文件可以被其他应用读取）和MODE_WORLD_WRITEABLE（当前文件可以被其他应用写入）</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>文件输出流</dd>
<dt><span class="throwsLabel">抛出:</span></dt>
<dd><code>java.io.FileNotFoundException</code> - 文件未发现异常</dd>
</dl>
</li>
</ul>
<a name="deleteFile-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>deleteFile</h4>
<pre>public&nbsp;boolean&nbsp;deleteFile(java.lang.String&nbsp;name)</pre>
<div class="block">删除指定名称的文件</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>deleteFile</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>name</code> - 指定文件的名称</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>是否删除成功（true：删除成功过；否则：false）</dd>
</dl>
</li>
</ul>
<a name="getFileStreamPath-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getFileStreamPath</h4>
<pre>public&nbsp;java.io.File&nbsp;getFileStreamPath(java.lang.String&nbsp;name)</pre>
<div class="block">获取文件流路径</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>getFileStreamPath</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>name</code> - 要获取文件流路径的文件的名称。</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>给定文件：包含文件流路径</dd>
</dl>
</li>
</ul>
<a name="fileList--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fileList</h4>
<pre>public&nbsp;java.lang.String[]&nbsp;fileList()</pre>
<div class="block">文件列表</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>fileList</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>一系列文件列表</dd>
</dl>
</li>
</ul>
<a name="getDataDir--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDataDir</h4>
<pre>public&nbsp;java.io.File&nbsp;getDataDir()</pre>
<div class="block">获取数据的目录</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>getDataDir</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>数据的目录</dd>
</dl>
</li>
</ul>
<a name="getFilesDir--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getFilesDir</h4>
<pre>public&nbsp;java.io.File&nbsp;getFilesDir()</pre>
<div class="block">获取内部存储文件的目录</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>getFilesDir</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>文件的目录</dd>
</dl>
</li>
</ul>
<a name="getNoBackupFilesDir--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getNoBackupFilesDir</h4>
<pre>public&nbsp;java.io.File&nbsp;getNoBackupFilesDir()</pre>
<div class="block">获取内部存储未备份的文件目录</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>getNoBackupFilesDir</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>未备份的文件目录</dd>
</dl>
</li>
</ul>
<a name="getExternalFilesDir-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getExternalFilesDir</h4>
<pre>public&nbsp;java.io.File&nbsp;getExternalFilesDir(java.lang.String&nbsp;type)</pre>
<div class="block">获取外部存储文件目录</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>getExternalFilesDir</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>type</code> - 类型
             <code>Environment.DIRECTORY_MUSIC</code>,
             <code>Environment.DIRECTORY_PODCASTS</code>,
             <code>Environment.DIRECTORY_RINGTONES</code>,
             <code>Environment.DIRECTORY_ALARMS</code>,
             <code>Environment.DIRECTORY_NOTIFICATIONS</code>,
             <code>Environment.DIRECTORY_PICTURES</code>, or
             <code>Environment.DIRECTORY_MOVIES</code>.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>外部存储文件目录</dd>
</dl>
</li>
</ul>
<a name="getExternalFilesDirs-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getExternalFilesDirs</h4>
<pre>public&nbsp;java.io.File[]&nbsp;getExternalFilesDirs(java.lang.String&nbsp;type)</pre>
<div class="block">获取一系列外部存储文件目录</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>getExternalFilesDirs</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>type</code> - 类型
             <code>Environment.DIRECTORY_MUSIC</code>,
             <code>Environment.DIRECTORY_PODCASTS</code>,
             <code>Environment.DIRECTORY_RINGTONES</code>,
             <code>Environment.DIRECTORY_ALARMS</code>,
             <code>Environment.DIRECTORY_NOTIFICATIONS</code>,
             <code>Environment.DIRECTORY_PICTURES</code>, or
             <code>Environment.DIRECTORY_MOVIES</code>.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>一系列外部存储文件目录</dd>
</dl>
</li>
</ul>
<a name="getObbDir--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getObbDir</h4>
<pre>public&nbsp;java.io.File&nbsp;getObbDir()</pre>
<div class="block">返回所有共享/外部存储设备上特定于应用程序的目录的绝对路径，其中可以找到应用程序的OBB文件（如果有）。
 请注意，如果应用程序没有任何OBB文件，则这些目录可能不存在。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>getObbDir</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>特定于应用程序的目录的绝对路径。</dd>
</dl>
</li>
</ul>
<a name="getObbDirs--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getObbDirs</h4>
<pre>public&nbsp;java.io.File[]&nbsp;getObbDirs()</pre>
<div class="block">返回所有共享/外部存储设备上特定于应用程序的目录的绝对路径，其中可以找到应用程序的OBB文件（如果有）。
 请注意，如果应用程序没有任何OBB文件，则这些目录可能不存在。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>getObbDirs</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>特定于应用程序的一系列目录的绝对路径。</dd>
</dl>
</li>
</ul>
<a name="getCacheDir--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getCacheDir</h4>
<pre>public&nbsp;java.io.File&nbsp;getCacheDir()</pre>
<div class="block">获取保存应用程序缓存文件的目录的路径。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>getCacheDir</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>保存应用程序缓存文件的目录的路径。</dd>
</dl>
</li>
</ul>
<a name="getCodeCacheDir--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getCodeCacheDir</h4>
<pre>public&nbsp;java.io.File&nbsp;getCodeCacheDir()</pre>
<div class="block">获取保存应用程序代码缓存文件的目录的路径。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>getCodeCacheDir</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>保存应用程序代码缓存文件的目录的路径。</dd>
</dl>
</li>
</ul>
<a name="getExternalCacheDir--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getExternalCacheDir</h4>
<pre>public&nbsp;java.io.File&nbsp;getExternalCacheDir()</pre>
<div class="block">获取应用程序特定目录的绝对路径。外部存储</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>getExternalCacheDir</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>应用程序特定目录的绝对路径。外部存储</dd>
</dl>
</li>
</ul>
<a name="getExternalCacheDirs--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getExternalCacheDirs</h4>
<pre>public&nbsp;java.io.File[]&nbsp;getExternalCacheDirs()</pre>
<div class="block">获取应用程序一系列特定目录的绝对路径。外部存储</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>getExternalCacheDirs</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>应用程序一系列特定目录的绝对路径。外部存储</dd>
</dl>
</li>
</ul>
<a name="getExternalMediaDirs--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getExternalMediaDirs</h4>
<pre>public&nbsp;java.io.File[]&nbsp;getExternalMediaDirs()</pre>
<div class="block">获取应用程序一系列特定目录的绝对路径。外部存储</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>getExternalMediaDirs</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>应用程序一系列特定目录的绝对路径。外部存储</dd>
</dl>
</li>
</ul>
<a name="getDir-java.lang.String-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDir</h4>
<pre>public&nbsp;java.io.File&nbsp;getDir(java.lang.String&nbsp;name,
                           int&nbsp;mode)</pre>
<div class="block">获取请求目录的<code>File</code>对象。 如果目录尚不存在，则将创建该目录。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>getDir</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>name</code> - 请求目录的名称</dd>
<dd><code>mode</code> - 操作模式，默认的模式为MODE_PRIVATE（代表该文件是私有数据，只能被应用本身访问，写入的内容会覆盖原文件的内容）。
             还可以使用MODE_APPEND（文件存在，直接在后面追加内容；不存在则新建）、MODE_WORLD_READABLE（当前文件可以被其他应用读取）和MODE_WORLD_WRITEABLE（当前文件可以被其他应用写入）</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>请求目录的<code>File</code>对象。 如果目录尚不存在，则将创建该目录。</dd>
</dl>
</li>
</ul>
<a name="openOrCreateDatabase-java.lang.String-int-android.database.sqlite.SQLiteDatabase.CursorFactory-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>openOrCreateDatabase</h4>
<pre>public&nbsp;android.database.sqlite.SQLiteDatabase&nbsp;openOrCreateDatabase(java.lang.String&nbsp;name,
                                                                   int&nbsp;mode,
                                                                   android.database.sqlite.SQLiteDatabase.CursorFactory&nbsp;factory)</pre>
<div class="block">打开与此Context的应用程序包关联的新私有SQLiteDatabase。 如果数据库文件不存在，创建该文件。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>openOrCreateDatabase</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>name</code> - 数据库的名称(在应用程序包中是惟一的)。</dd>
<dd><code>mode</code> - 操作模式，默认的模式为MODE_PRIVATE（代表该文件是私有数据，只能被应用本身访问，写入的内容会覆盖原文件的内容）。
                还可以使用MODE_APPEND（文件存在，直接在后面追加内容；不存在则新建）、MODE_WORLD_READABLE（当前文件可以被其他应用读取）和MODE_WORLD_WRITEABLE（当前文件可以被其他应用写入）</dd>
<dd><code>factory</code> - 一个可选的工厂类，在查询被调用时被调用来实例化游标。</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>具有给定名称的新创建数据库的内容</dd>
</dl>
</li>
</ul>
<a name="openOrCreateDatabase-java.lang.String-int-android.database.sqlite.SQLiteDatabase.CursorFactory-android.database.DatabaseErrorHandler-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>openOrCreateDatabase</h4>
<pre>public&nbsp;android.database.sqlite.SQLiteDatabase&nbsp;openOrCreateDatabase(java.lang.String&nbsp;name,
                                                                   int&nbsp;mode,
                                                                   android.database.sqlite.SQLiteDatabase.CursorFactory&nbsp;factory,
                                                                   android.database.DatabaseErrorHandler&nbsp;errorHandler)</pre>
<div class="block">打开与此Context的应用程序包关联的新私有SQLiteDatabase。 如果数据库文件不存在，创建该文件。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>openOrCreateDatabase</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>name</code> - 数据库的名称(在应用程序包中是惟一的)。</dd>
<dd><code>mode</code> - 操作模式，默认的模式为MODE_PRIVATE（代表该文件是私有数据，只能被应用本身访问，写入的内容会覆盖原文件的内容）。
                     还可以使用MODE_APPEND（文件存在，直接在后面追加内容；不存在则新建）、MODE_WORLD_READABLE（当前文件可以被其他应用读取）和MODE_WORLD_WRITEABLE（当前文件可以被其他应用写入）</dd>
<dd><code>factory</code> - 一个可选的工厂类，在查询被调用时被调用来实例化游标。</dd>
<dd><code>errorHandler</code> - 当sqlite报告数据库损坏时要使用的<code>DatabaseErrorHandler</code>。 如果为null，则假定为<code>DefaultDatabaseErrorHandler</code>。</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>具有给定名称的新创建数据库的内容</dd>
</dl>
</li>
</ul>
<a name="moveDatabaseFrom-android.content.Context-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>moveDatabaseFrom</h4>
<pre>public&nbsp;boolean&nbsp;moveDatabaseFrom(android.content.Context&nbsp;sourceContext,
                                java.lang.String&nbsp;name)</pre>
<div class="block">将现有数据库文件从给定的源存储上下文移动到此上下文。 这通常用于在升级后在存储位置之间迁移数据，例如迁移到受设备保护的存储。
 数据库必须在移动前关闭。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>moveDatabaseFrom</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>sourceContext</code> - 包含要移动的现有数据库的源上下文。</dd>
<dd><code>name</code> - 数据库文件名</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>如果移动成功或者源数据库中不存在数据库：true；否则false。</dd>
</dl>
</li>
</ul>
<a name="deleteDatabase-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>deleteDatabase</h4>
<pre>public&nbsp;boolean&nbsp;deleteDatabase(java.lang.String&nbsp;name)</pre>
<div class="block">删除数据库</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>deleteDatabase</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>name</code> - 数据库文件名</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>如果删除成功：true；否则false。</dd>
</dl>
</li>
</ul>
<a name="getDatabasePath-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDatabasePath</h4>
<pre>public&nbsp;java.io.File&nbsp;getDatabasePath(java.lang.String&nbsp;name)</pre>
<div class="block">获取数据库的路径</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>getDatabasePath</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>name</code> - 数据库文件名</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>包含有数据库路径的对应文件</dd>
</dl>
</li>
</ul>
<a name="databaseList--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>databaseList</h4>
<pre>public&nbsp;java.lang.String[]&nbsp;databaseList()</pre>
<div class="block">一系列数据库</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>databaseList</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
</dl>
</li>
</ul>
<a name="getWallpaper--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getWallpaper</h4>
<pre>public&nbsp;android.graphics.drawable.Drawable&nbsp;getWallpaper()</pre>
<div class="block">获取壁纸</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>getWallpaper</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>Drawable（可绘制的、图片）对象</dd>
</dl>
</li>
</ul>
<a name="peekWallpaper--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>peekWallpaper</h4>
<pre>public&nbsp;android.graphics.drawable.Drawable&nbsp;peekWallpaper()</pre>
<div class="block">检索当前系统壁纸; 如果没有设置壁纸，则返回空指针。 这将作为抽象Drawable返回，您可以在View中安装它以显示用户当前设置的任何壁纸。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>peekWallpaper</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>Drawable（可绘制的、图片）对象</dd>
</dl>
</li>
</ul>
<a name="getWallpaperDesiredMinimumWidth--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getWallpaperDesiredMinimumWidth</h4>
<pre>public&nbsp;int&nbsp;getWallpaperDesiredMinimumWidth()</pre>
<div class="block">获取壁纸所需的最小宽度</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>getWallpaperDesiredMinimumWidth</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>壁纸所需的最小宽度</dd>
</dl>
</li>
</ul>
<a name="getWallpaperDesiredMinimumHeight--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getWallpaperDesiredMinimumHeight</h4>
<pre>public&nbsp;int&nbsp;getWallpaperDesiredMinimumHeight()</pre>
<div class="block">获取壁纸所需的最小高度</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>getWallpaperDesiredMinimumHeight</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>壁纸所需的最小高度</dd>
</dl>
</li>
</ul>
<a name="setWallpaper-android.graphics.Bitmap-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setWallpaper</h4>
<pre>public&nbsp;void&nbsp;setWallpaper(android.graphics.Bitmap&nbsp;bitmap)
                  throws java.io.IOException</pre>
<div class="block">设置壁纸</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>setWallpaper</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>bitmap</code> - 将用作新系统墙纸的bitmap位图。</dd>
<dt><span class="throwsLabel">抛出:</span></dt>
<dd><code>java.io.IOException</code> - 如果尝试将壁纸设置为提供的图像时发生错误。</dd>
</dl>
</li>
</ul>
<a name="setWallpaper-java.io.InputStream-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setWallpaper</h4>
<pre>public&nbsp;void&nbsp;setWallpaper(java.io.InputStream&nbsp;data)
                  throws java.io.IOException</pre>
<div class="block">设置壁纸</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>setWallpaper</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>data</code> - 包含要作为墙纸安装的原始数据的流。</dd>
<dt><span class="throwsLabel">抛出:</span></dt>
<dd><code>java.io.IOException</code> - 如果尝试将壁纸设置为提供的图像时发生错误。</dd>
</dl>
</li>
</ul>
<a name="clearWallpaper--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearWallpaper</h4>
<pre>public&nbsp;void&nbsp;clearWallpaper()
                    throws java.io.IOException</pre>
<div class="block">删除任何当前设置的系统壁纸，恢复到系统的内置壁纸。 成功时，广播意图<code>Intent＃ACTION_WALLPAPER_CHANGED</code>。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>clearWallpaper</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="throwsLabel">抛出:</span></dt>
<dd><code>java.io.IOException</code> - 输入输出异常</dd>
</dl>
</li>
</ul>
<a name="startActivity-android.content.Intent-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>startActivity</h4>
<pre>public&nbsp;void&nbsp;startActivity(android.content.Intent&nbsp;intent)</pre>
<div class="block">开启一个新的Activity</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>startActivity</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>intent</code> - 要启动的Activity的描述</dd>
</dl>
</li>
</ul>
<a name="startActivity-android.content.Intent-android.os.Bundle-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>startActivity</h4>
<pre>public&nbsp;void&nbsp;startActivity(android.content.Intent&nbsp;intent,
                          android.os.Bundle&nbsp;options)</pre>
<div class="block">开启一个新的Activity</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>startActivity</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>intent</code> - 要启动的Activity的描述</dd>
<dd><code>options</code> - 有关如何启动活动的其他选项。</dd>
</dl>
</li>
</ul>
<a name="startActivities-android.content.Intent:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>startActivities</h4>
<pre>public&nbsp;void&nbsp;startActivities(android.content.Intent[]&nbsp;intents)</pre>
<div class="block">开启一系列新的Activity</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>startActivities</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>intents</code> - 要启动的Intent数组</dd>
</dl>
</li>
</ul>
<a name="startActivities-android.content.Intent:A-android.os.Bundle-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>startActivities</h4>
<pre>public&nbsp;void&nbsp;startActivities(android.content.Intent[]&nbsp;intents,
                            android.os.Bundle&nbsp;options)</pre>
<div class="block">开启一系列新的Activity</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>startActivities</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>intents</code> - 要启动的Intent数组</dd>
<dd><code>options</code> - 有关如何启动Activity的其他选项。</dd>
</dl>
</li>
</ul>
<a name="startIntentSender-android.content.IntentSender-android.content.Intent-int-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>startIntentSender</h4>
<pre>public&nbsp;void&nbsp;startIntentSender(android.content.IntentSender&nbsp;intent,
                              android.content.Intent&nbsp;fillInIntent,
                              int&nbsp;flagsMask,
                              int&nbsp;flagsValues,
                              int&nbsp;extraFlags)
                       throws android.content.IntentSender.SendIntentException</pre>
<div class="block">像<code>#startActivity（Intent，Bundle）</code>一样，但是要开始使用IntentSender。
 如果IntentSender用于某个活动，那么该活动将好比在此处调用常规<code>#startActivity（Intent）</code>一样启动; 否则，将执行其相关操作（例如发送广播），就像好比已在其上调用<code>#sendIntent IntentSender.sendIntent</code>一样。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>startIntentSender</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>intent</code> - 要启动的IntentSender。</dd>
<dd><code>fillInIntent</code> - 如果为非null，则将其作为<code>#sendIntent</code>的intent参数提供。</dd>
<dd><code>flagsMask</code> - 您将要更改的原始IntentSender中的Intent标志。</dd>
<dd><code>flagsValues</code> - flagsMask 中设置的任何位的所需值</dd>
<dd><code>extraFlags</code> - 始终设为0。</dd>
<dt><span class="throwsLabel">抛出:</span></dt>
<dd><code>IntentSender.SendIntentException</code> - 发送Intent时的异常</dd>
</dl>
</li>
</ul>
<a name="startIntentSender-android.content.IntentSender-android.content.Intent-int-int-int-android.os.Bundle-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>startIntentSender</h4>
<pre>public&nbsp;void&nbsp;startIntentSender(android.content.IntentSender&nbsp;intent,
                              android.content.Intent&nbsp;fillInIntent,
                              int&nbsp;flagsMask,
                              int&nbsp;flagsValues,
                              int&nbsp;extraFlags,
                              android.os.Bundle&nbsp;options)
                       throws android.content.IntentSender.SendIntentException</pre>
<div class="block">像<code>#startActivity（Intent，Bundle）</code>一样，但是要开始使用IntentSender。
 如果IntentSender用于某个活动，那么该活动将好比在此处调用常规<code>#startActivity（Intent）</code>一样启动; 否则，将执行其相关操作（例如发送广播），就像好比已在其上调用<code>#sendIntent IntentSender.sendIntent</code>一样。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>startIntentSender</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>intent</code> - 要启动的IntentSender。</dd>
<dd><code>fillInIntent</code> - 如果为非null，则将其作为<code>#sendIntent</code>的intent参数提供。</dd>
<dd><code>flagsMask</code> - 您将要更改的原始IntentSender中的Intent标志。</dd>
<dd><code>flagsValues</code> - flagsMask 中设置的任何位的所需值</dd>
<dd><code>extraFlags</code> - 始终设为0。</dd>
<dd><code>options</code> - 有关如何启动Activity的其他选项。</dd>
<dt><span class="throwsLabel">抛出:</span></dt>
<dd><code>IntentSender.SendIntentException</code> - 发送Intent时的异常</dd>
</dl>
</li>
</ul>
<a name="sendBroadcast-android.content.Intent-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sendBroadcast</h4>
<pre>public&nbsp;void&nbsp;sendBroadcast(android.content.Intent&nbsp;intent)</pre>
<div class="block">将给定意图广播给所有感兴趣的BroadcastReceivers，允许强制执行可选的必需权限。 这个调用是异步的; 它会立即返回，并且您将在接收器运行时继续执行。没有结果从接收器传播，接收器不能中止广播。
 如果要允许接收方传播结果或中止广播，则必须使用<code>#sendOrderedBroadcast（Intent，String）</code>发送有序广播。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>sendBroadcast</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>intent</code> - 广播的Intent; 匹配此Intent的所有接收器都将接收广播。</dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><code>BroadcastReceiver</code></dd>
</dl>
</li>
</ul>
<a name="sendBroadcast-android.content.Intent-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sendBroadcast</h4>
<pre>public&nbsp;void&nbsp;sendBroadcast(android.content.Intent&nbsp;intent,
                          java.lang.String&nbsp;receiverPermission)</pre>
<div class="block">将给定意图广播给所有感兴趣的BroadcastReceivers，允许强制执行可选的必需权限。 这个调用是异步的; 它会立即返回，并且您将在接收器运行时继续执行。没有结果从接收器传播，接收器不能中止广播。
 如果要允许接收方传播结果或中止广播，则必须使用<code>#sendOrderedBroadcast（Intent，String）</code>发送有序广播。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>sendBroadcast</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>intent</code> - 广播的Intent; 匹配此Intent的所有接收器都将接收广播。</dd>
<dd><code>receiverPermission</code> - （可选）字符串命名接收方必须保留的权限才能接收您的广播。 如果为null，则不需要任何权限。</dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><code>BroadcastReceiver</code></dd>
</dl>
</li>
</ul>
<a name="sendOrderedBroadcast-android.content.Intent-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sendOrderedBroadcast</h4>
<pre>public&nbsp;void&nbsp;sendOrderedBroadcast(android.content.Intent&nbsp;intent,
                                 java.lang.String&nbsp;receiverPermission)</pre>
<div class="block">允许您从广播中接收数据。 这是通过在调用时提供自己的BroadcastReceiver来实现的，在广播结束时将其视为最终接收者 - 将调用其<code>BroadcastReceiver＃onReceive</code>方法，并从其他接收者收集结果值。
 广播将以与调用<code>#sendOrderedBroadcast（Intent，String）</code>相同的方式进行序列化。
 与<code>#sendBroadcast（Intent）</code>一样，此方法是异步的; 它将在调用resultReceiver.onReceive（）之前返回。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>sendOrderedBroadcast</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>intent</code> - 广播的Intent; 匹配此Intent的所有接收器都将接收广播。</dd>
<dd><code>receiverPermission</code> - 字符串命名接收者必须持有的权限才能接收您的广播。 如果为null，则不需要任何权限。</dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><code>BroadcastReceiver</code></dd>
</dl>
</li>
</ul>
<a name="sendOrderedBroadcast-android.content.Intent-java.lang.String-android.content.BroadcastReceiver-android.os.Handler-int-java.lang.String-android.os.Bundle-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sendOrderedBroadcast</h4>
<pre>public&nbsp;void&nbsp;sendOrderedBroadcast(android.content.Intent&nbsp;intent,
                                 java.lang.String&nbsp;receiverPermission,
                                 android.content.BroadcastReceiver&nbsp;resultReceiver,
                                 android.os.Handler&nbsp;scheduler,
                                 int&nbsp;initialCode,
                                 java.lang.String&nbsp;initialData,
                                 android.os.Bundle&nbsp;initialExtras)</pre>
<div class="block">允许您从广播中接收数据。 这是通过在调用时提供自己的BroadcastReceiver来实现的，在广播结束时将其视为最终接收者 - 将调用其<code>BroadcastReceiver＃onReceive</code>方法，并从其他接收者收集结果值。
 广播将以与调用<code>#sendOrderedBroadcast（Intent，String）</code>相同的方式进行序列化。
 与<code>#sendBroadcast（Intent）</code>一样，此方法是异步的; 它将在调用resultReceiver.onReceive（）之前返回。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>sendOrderedBroadcast</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>intent</code> - 广播的Intent; 匹配此Intent的所有接收器都将接收广播。</dd>
<dd><code>receiverPermission</code> - 字符串命名接收者必须持有的权限才能接收您的广播。 如果为null，则不需要任何权限。</dd>
<dd><code>resultReceiver</code> - 你自己的BroadcastReceiver被视为广播的最终接收者。</dd>
<dd><code>scheduler</code> - 用于调度resultReceiver回调的自定义处理程序; 如果为null，它将在Context的主线程中进行调度。</dd>
<dd><code>initialCode</code> - 结果代码的初始值。 通常是Activity.RESULT_OK。</dd>
<dd><code>initialData</code> - 结果数据的初始值。 通常为空。</dd>
<dd><code>initialExtras</code> - 结果额外的初始值。 通常为空。</dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><code>BroadcastReceiver</code></dd>
</dl>
</li>
</ul>
<a name="sendBroadcastAsUser-android.content.Intent-android.os.UserHandle-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sendBroadcastAsUser</h4>
<pre>public&nbsp;void&nbsp;sendBroadcastAsUser(android.content.Intent&nbsp;intent,
                                android.os.UserHandle&nbsp;user)</pre>
<div class="block">允许您指定广播将被发送到的用户。 这不适用于未预先安装在系统映像上的应用程序。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>sendBroadcastAsUser</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>intent</code> - 广播的Intent; 匹配此Intent的所有接收器都将接收广播。</dd>
<dd><code>user</code> - UserHandle发送Intent。</dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><code>BroadcastReceiver</code></dd>
</dl>
</li>
</ul>
<a name="sendBroadcastAsUser-android.content.Intent-android.os.UserHandle-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sendBroadcastAsUser</h4>
<pre>public&nbsp;void&nbsp;sendBroadcastAsUser(android.content.Intent&nbsp;intent,
                                android.os.UserHandle&nbsp;user,
                                java.lang.String&nbsp;receiverPermission)</pre>
<div class="block">允许您指定广播将被发送到的用户。 这不适用于未预先安装在系统映像上的应用程序。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>sendBroadcastAsUser</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>intent</code> - 广播的Intent; 匹配此Intent的所有接收器都将接收广播。</dd>
<dd><code>user</code> - UserHandle发送Intent。</dd>
<dd><code>receiverPermission</code> - 字符串命名接收者必须持有的权限才能接收您的广播。 如果为null，则不需要任何权限。</dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><code>BroadcastReceiver</code></dd>
</dl>
</li>
</ul>
<a name="sendOrderedBroadcastAsUser-android.content.Intent-android.os.UserHandle-java.lang.String-android.content.BroadcastReceiver-android.os.Handler-int-java.lang.String-android.os.Bundle-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sendOrderedBroadcastAsUser</h4>
<pre>public&nbsp;void&nbsp;sendOrderedBroadcastAsUser(android.content.Intent&nbsp;intent,
                                       android.os.UserHandle&nbsp;user,
                                       java.lang.String&nbsp;receiverPermission,
                                       android.content.BroadcastReceiver&nbsp;resultReceiver,
                                       android.os.Handler&nbsp;scheduler,
                                       int&nbsp;initialCode,
                                       java.lang.String&nbsp;initialData,
                                       android.os.Bundle&nbsp;initialExtras)</pre>
<div class="block">允许您指定广播将被发送到的用户。 这不适用于未预先安装在系统映像上的应用程序。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>sendOrderedBroadcastAsUser</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>intent</code> - 广播的Intent; 匹配此Intent的所有接收器都将接收广播。</dd>
<dd><code>user</code> - UserHandle发送Intent。</dd>
<dd><code>receiverPermission</code> - 字符串命名接收者必须持有的权限才能接收您的广播。 如果为null，则不需要任何权限。</dd>
<dd><code>resultReceiver</code> - 你自己的BroadcastReceiver被视为广播的最终接收者。</dd>
<dd><code>scheduler</code> - 用于调度resultReceiver回调的自定义处理程序; 如果为null，它将在Context的主线程中进行调度。</dd>
<dd><code>initialCode</code> - 结果代码的初始值。 通常是Activity.RESULT_OK。</dd>
<dd><code>initialData</code> - 结果数据的初始值。 通常为空。</dd>
<dd><code>initialExtras</code> - 结果额外的初始值。 通常为空。</dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><code>BroadcastReceiver</code></dd>
</dl>
</li>
</ul>
<a name="sendStickyBroadcast-android.content.Intent-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sendStickyBroadcast</h4>
<pre>public&nbsp;void&nbsp;sendStickyBroadcast(android.content.Intent&nbsp;intent)</pre>
<div class="block">执行“粘性”的<code>#sendBroadcast（Intent）</code>，这意味着您发送的意图在广播完成后保持不变，以便其他人可以通过 <a href="../../../com/lzf/myhfuteducn/LzfApplication.html#registerReceiver-android.content.BroadcastReceiver-android.content.IntentFilter-"><code>registerReceiver(BroadcastReceiver, IntentFilter)</code></a>的返回值快速检索该数据。 在所有其他方面，这与<code>#sendBroadcast（Intent）</code>的行为相同。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>sendStickyBroadcast</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>intent</code> - 广播Intent; 匹配此Intent的所有接收器将接收广播，并且Intent将被保留以重新广播给未来的接收器。</dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><code>BroadcastReceiver</code></dd>
</dl>
</li>
</ul>
<a name="sendStickyOrderedBroadcast-android.content.Intent-android.content.BroadcastReceiver-android.os.Handler-int-java.lang.String-android.os.Bundle-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sendStickyOrderedBroadcast</h4>
<pre>public&nbsp;void&nbsp;sendStickyOrderedBroadcast(android.content.Intent&nbsp;intent,
                                       android.content.BroadcastReceiver&nbsp;resultReceiver,
                                       android.os.Handler&nbsp;scheduler,
                                       int&nbsp;initialCode,
                                       java.lang.String&nbsp;initialData,
                                       android.os.Bundle&nbsp;initialExtras)</pre>
<div class="block">允许您从广播中接收数据。 这是通过在调用时提供自己的BroadcastReceiver来实现的，在广播结束时将其视为最终接收者 - 将调用其<code>BroadcastReceiver＃onReceive</code>方法，并从其他接收者收集结果值。
 广播将以与调用<code>#sendOrderedBroadcast（Intent，String）</code>相同的方式进行序列化。
 与<code>#sendBroadcast（Intent）</code>一样，此方法是异步的; 它将在调用resultReceiver.onReceive（）之前返回。 请注意，存储的粘性数据仅是您最初提供给广播的数据，而不是接收方所做的任何更改的结果。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>sendStickyOrderedBroadcast</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>intent</code> - 广播的Intent; 匹配此Intent的所有接收器都将接收广播。</dd>
<dd><code>resultReceiver</code> - 你自己的BroadcastReceiver被视为广播的最终接收者。</dd>
<dd><code>scheduler</code> - 用于调度resultReceiver回调的自定义处理程序; 如果为null，它将在Context的主线程中进行调度。</dd>
<dd><code>initialCode</code> - 结果代码的初始值。 通常是Activity.RESULT_OK。</dd>
<dd><code>initialData</code> - 结果数据的初始值。 通常为空。</dd>
<dd><code>initialExtras</code> - 结果额外的初始值。 通常为空。</dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><code>BroadcastReceiver</code></dd>
</dl>
</li>
</ul>
<a name="removeStickyBroadcast-android.content.Intent-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>removeStickyBroadcast</h4>
<pre>public&nbsp;void&nbsp;removeStickyBroadcast(android.content.Intent&nbsp;intent)</pre>
<div class="block">删除先前使用<a href="../../../com/lzf/myhfuteducn/LzfApplication.html#sendStickyBroadcast-android.content.Intent-"><code>sendStickyBroadcast(android.content.Intent)</code></a>发送的数据，这样就好像粘性广播从未发生过一样。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>removeStickyBroadcast</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>intent</code> - 先前广播的意图。</dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><code>BroadcastReceiver</code></dd>
</dl>
</li>
</ul>
<a name="sendStickyBroadcastAsUser-android.content.Intent-android.os.UserHandle-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sendStickyBroadcastAsUser</h4>
<pre>public&nbsp;void&nbsp;sendStickyBroadcastAsUser(android.content.Intent&nbsp;intent,
                                      android.os.UserHandle&nbsp;user)</pre>
<div class="block">允许您指定广播将被发送到的用户。 这不适用于未预先安装在系统映像上的应用程序。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>sendStickyBroadcastAsUser</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>intent</code> - 广播的Intent; 匹配此Intent的所有接收器都将接收广播。</dd>
<dd><code>user</code> - UserHandle发送Intent。</dd>
</dl>
</li>
</ul>
<a name="sendStickyOrderedBroadcastAsUser-android.content.Intent-android.os.UserHandle-android.content.BroadcastReceiver-android.os.Handler-int-java.lang.String-android.os.Bundle-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sendStickyOrderedBroadcastAsUser</h4>
<pre>public&nbsp;void&nbsp;sendStickyOrderedBroadcastAsUser(android.content.Intent&nbsp;intent,
                                             android.os.UserHandle&nbsp;user,
                                             android.content.BroadcastReceiver&nbsp;resultReceiver,
                                             android.os.Handler&nbsp;scheduler,
                                             int&nbsp;initialCode,
                                             java.lang.String&nbsp;initialData,
                                             android.os.Bundle&nbsp;initialExtras)</pre>
<div class="block">允许您指定广播将被发送到的用户。 这不适用于未预先安装在系统映像上的应用程序。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>sendStickyOrderedBroadcastAsUser</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>intent</code> - 广播的Intent; 匹配此Intent的所有接收器都将接收广播。</dd>
<dd><code>user</code> - UserHandle发送Intent。</dd>
<dd><code>resultReceiver</code> - 你自己的BroadcastReceiver被视为广播的最终接收者。</dd>
<dd><code>scheduler</code> - 用于调度resultReceiver回调的自定义处理程序; 如果为null，它将在Context的主线程中进行调度。</dd>
<dd><code>initialCode</code> - 结果代码的初始值。 通常是Activity.RESULT_OK。</dd>
<dd><code>initialData</code> - 结果数据的初始值。 通常为空。</dd>
<dd><code>initialExtras</code> - 结果额外的初始值。 通常为空。</dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><code>BroadcastReceiver</code></dd>
</dl>
</li>
</ul>
<a name="removeStickyBroadcastAsUser-android.content.Intent-android.os.UserHandle-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>removeStickyBroadcastAsUser</h4>
<pre>public&nbsp;void&nbsp;removeStickyBroadcastAsUser(android.content.Intent&nbsp;intent,
                                        android.os.UserHandle&nbsp;user)</pre>
<div class="block">允许您移除指定广播将被发送到的用户。 这不适用于未预先安装在系统映像上的应用程序。
 您必须持有<code>android.Manifest.permission＃BROADCAST_STICKY</code>权限才能使用此API。 如果您未持有该权限，则会抛出<code>SecurityException</code>。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>removeStickyBroadcastAsUser</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>intent</code> - 先前广播的Intent。</dd>
<dd><code>user</code> - UserHandle删除粘性广播。</dd>
</dl>
</li>
</ul>
<a name="registerReceiver-android.content.BroadcastReceiver-android.content.IntentFilter-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>registerReceiver</h4>
<pre>public&nbsp;android.content.Intent&nbsp;registerReceiver(android.content.BroadcastReceiver&nbsp;receiver,
                                               android.content.IntentFilter&nbsp;filter)</pre>
<div class="block">注册Intent广播的接收器，在scheduler的上下文中运行。 有关更多信息，请参阅<code>#registerReceiver（BroadcastReceiver，IntentFilter）</code>。
 这允许您指定谁可以接收哪些广播意图或让接收者在与主应用程序线程不同的线程中运行。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>registerReceiver</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>receiver</code> - 广播接收器来处理广播。</dd>
<dd><code>filter</code> - 选择要接收的 Intent广播。</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>找到匹配 filter 的第一个粘性意图，如果没有，则返回null。</dd>
</dl>
</li>
</ul>
<a name="registerReceiver-android.content.BroadcastReceiver-android.content.IntentFilter-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>registerReceiver</h4>
<pre>public&nbsp;android.content.Intent&nbsp;registerReceiver(android.content.BroadcastReceiver&nbsp;receiver,
                                               android.content.IntentFilter&nbsp;filter,
                                               int&nbsp;flags)</pre>
<div class="block">注册Intent广播的接收器，在scheduler的上下文中运行。 有关更多信息，请参阅<code>#registerReceiver（BroadcastReceiver，IntentFilter）</code>。
 这允许您指定谁可以接收哪些广播意图或让接收者在与主应用程序线程不同的线程中运行。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>registerReceiver</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>receiver</code> - 广播接收器来处理广播。</dd>
<dd><code>filter</code> - 选择要接收的 Intent广播。</dd>
<dd><code>flags</code> - 接收器的附加选项。 可能是0或<code>Context.RECEIVER_VISIBLE_TO_INSTANT_APPS</code>。</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>找到匹配 filter 的第一个粘性意图，如果没有，则返回null。</dd>
</dl>
</li>
</ul>
<a name="registerReceiver-android.content.BroadcastReceiver-android.content.IntentFilter-java.lang.String-android.os.Handler-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>registerReceiver</h4>
<pre>public&nbsp;android.content.Intent&nbsp;registerReceiver(android.content.BroadcastReceiver&nbsp;receiver,
                                               android.content.IntentFilter&nbsp;filter,
                                               java.lang.String&nbsp;broadcastPermission,
                                               android.os.Handler&nbsp;scheduler)</pre>
<div class="block">注册Intent广播的接收器，在scheduler的上下文中运行。 有关更多信息，请参阅<code>#registerReceiver（BroadcastReceiver，IntentFilter）</code>。
 这允许您指定谁可以接收哪些广播意图或让接收者在与主应用程序线程不同的线程中运行。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>registerReceiver</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>receiver</code> - 广播接收器来处理广播。</dd>
<dd><code>filter</code> - 选择要接收的 Intent广播。</dd>
<dd><code>broadcastPermission</code> - 字符串命名广播必须拥有的权限才能向您发送意图。 如果为null，则不需要任何权限。</dd>
<dd><code>scheduler</code> - 处理程序标识将接收Intent的线程。 如果为null，则将使用该进程的主线程。</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>找到匹配 filter 的第一个粘性意图，如果没有，则返回null。</dd>
</dl>
</li>
</ul>
<a name="registerReceiver-android.content.BroadcastReceiver-android.content.IntentFilter-java.lang.String-android.os.Handler-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>registerReceiver</h4>
<pre>public&nbsp;android.content.Intent&nbsp;registerReceiver(android.content.BroadcastReceiver&nbsp;receiver,
                                               android.content.IntentFilter&nbsp;filter,
                                               java.lang.String&nbsp;broadcastPermission,
                                               android.os.Handler&nbsp;scheduler,
                                               int&nbsp;flags)</pre>
<div class="block">注册Intent广播的接收器，在scheduler的上下文中运行。 有关更多信息，请参阅<code>#registerReceiver（BroadcastReceiver，IntentFilter）</code>。
 这允许您指定谁可以接收哪些广播意图或让接收者在与主应用程序线程不同的线程中运行。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>registerReceiver</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>receiver</code> - 广播接收器来处理广播。</dd>
<dd><code>filter</code> - 选择要接收的 Intent广播。</dd>
<dd><code>broadcastPermission</code> - 字符串命名广播必须拥有的权限才能向您发送意图。 如果为null，则不需要任何权限。</dd>
<dd><code>scheduler</code> - 处理程序标识将接收Intent的线程。 如果为null，则将使用该进程的主线程。</dd>
<dd><code>flags</code> - 接收器的附加选项。 可能是0或<code>Context.RECEIVER_VISIBLE_TO_INSTANT_APPS</code>。</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>找到匹配 filter 的第一个粘性意图，如果没有，则返回null。</dd>
</dl>
</li>
</ul>
<a name="unregisterReceiver-android.content.BroadcastReceiver-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>unregisterReceiver</h4>
<pre>public&nbsp;void&nbsp;unregisterReceiver(android.content.BroadcastReceiver&nbsp;receiver)</pre>
<div class="block">取消注册以前注册的BroadcastReceiver。 将删除已为此BroadcastReceiver注册的所有过滤器。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>unregisterReceiver</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>receiver</code> - 要取消注册的广播接收器。</dd>
</dl>
</li>
</ul>
<a name="startService-android.content.Intent-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>startService</h4>
<pre>public&nbsp;android.content.ComponentName&nbsp;startService(android.content.Intent&nbsp;service)</pre>
<div class="block">请求启动给定的应用程序服务。 Intent应该包含要启动的特定服务实现的完整类名，或者要包含的特定包名。如果指定的Intent较少，则会记录有关此内容的警告。在这种情况下，可以使用任何多个匹配服务。如果此服务尚未运行，它将被实例化并启动（如果需要，为其创建一个进程）;如果它正在运行，那么它仍然在运行。
 对此方法的每次调用都将导致对目标服务的<code>android.app.Service＃onStartCommand</code>方法的相应调用。这提供了一种将作业提交到服务的便捷方式，而无需绑定和调用其接口。
 使用startService（）会覆盖由<a href="../../../com/lzf/myhfuteducn/LzfApplication.html#bindService-android.content.Intent-android.content.ServiceConnection-int-"><code>bindService(android.content.Intent, android.content.ServiceConnection, int)</code></a>管理的默认服务生命周期：它要求服务在调用<a href="../../../com/lzf/myhfuteducn/LzfApplication.html#stopService-android.content.Intent-"><code>stopService(android.content.Intent)</code></a>之前保持运行，无论是否有任何客户端连接到它。请注意，对startService（）的调用不会嵌套：无论您调用startService（）多少次，对<a href="../../../com/lzf/myhfuteducn/LzfApplication.html#stopService-android.content.Intent-"><code>stopService(android.content.Intent)</code></a>的单次调用都会将其停止。
 系统尝试尽可能地保持运行服务。它们应该被停止的唯一时间是当前前台应用程序使用如此多的资源以使服务需要被杀死。如果服务进程中发生任何错误，它将自动重新启动。
 如果您没有启动给定服务的权限，此函数将抛出<code>SecurityException</code>。
 每次调用startService（）都会导致系统完成大量工作，以管理围绕意图处理的服务生命周期，这可能需要几毫秒的CPU时间。由于此成本，startService（）不应用于频繁向service传递intent，仅用于安排重要工作。使用<a href="../../../com/lzf/myhfuteducn/LzfApplication.html#bindService-android.content.Intent-android.content.ServiceConnection-int-"><code>bound services</code></a>进行高频呼叫。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>startService</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>service</code> - 标识要启动的服务。 Intent必须完全显式（提供组件名称）。 Intent extras中可能包含其他值以提供参数以及此特定的启动调用。</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>如果服务正在启动或已在运行，则返回已启动的实际服务的<code>ComponentName</code>; 否则，如果服务不存在，则返回null。</dd>
</dl>
</li>
</ul>
<a name="startForegroundService-android.content.Intent-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>startForegroundService</h4>
<pre>public&nbsp;android.content.ComponentName&nbsp;startForegroundService(android.content.Intent&nbsp;service)</pre>
<div class="block">类似于<code>#startService（Intent）</code>，但隐含的承诺是服务将调用<code>）</code>一旦它开始运行。
 为此提供服务的时间与ANR(Application Not responding)间隔相当，否则系统将自动停止服务并声明应用程序ANR(Application Not responding)。
 与普通的<code>#startService（Intent）</code>不同，此方法可以随时使用，无论托管服务的应用程序是否处于前台状态。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>startForegroundService</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>service</code> - 标识要启动的服务。 Intent必须完全显式（提供组件名称）。 Intent extras中可能包含其他值以提供参数以及此特定的启动调用。</dd>
<dt><span class="returnLabel">返回:</span></dt>
</dl>
</li>
</ul>
<a name="stopService-android.content.Intent-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>stopService</h4>
<pre>public&nbsp;boolean&nbsp;stopService(android.content.Intent&nbsp;name)</pre>
<div class="block">请求停止给定的应用程序服务。 如果服务没有运行，则没有任何反应。 否则它会停止。 请注意，不计算对startService（）的调用 - 无论启动多少次，都会停止服务。
 请注意，如果已停止的服务仍然绑定了<code>ServiceConnection</code>对象且设置了<code>Context.BIND_AUTO_CREATE</code>，则在删除所有这些绑定之前不会销毁它。 有关服务生命周期的更多详细信息，请参阅<code>Service</code>文档。
 如果您没有权限停止给定服务，则此函数将抛出<code>SecurityException</code>。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>stopService</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>name</code> - 要停止的服务的描述。 Intent必须完全显式（提供组件名称）或指定它所针对的特定包名称。</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>如果有一个服务匹配已经运行的给定Intent，那么它将被停止并返回<code>true</code>; 否则返回<code>false</code>。</dd>
</dl>
</li>
</ul>
<a name="bindService-android.content.Intent-android.content.ServiceConnection-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>bindService</h4>
<pre>public&nbsp;boolean&nbsp;bindService(android.content.Intent&nbsp;service,
                           android.content.ServiceConnection&nbsp;conn,
                           int&nbsp;flags)</pre>
<div class="block">连接到应用程序服务，根据需要创建它。这定义了应用程序和服务之间的依赖关系。给定的conn将在创建时接收服务对象，并告知它是否死亡并重新启动。只要存在调用上下文，系统就会认为该服务是必需的。例如，如果此Context是一个已停止的Activity，则在恢复Activity之前，不需要该服务继续运行。
 如果您没有绑定到给定服务的权限，则此函数将抛出<code>SecurityException</code>。
 注意：无法从<code>BroadcastReceiver</code>组件调用此方法 。
 可用于从BroadcastReceiver与服务通信的模式是使用包含要发送的命令的参数调用<a href="../../../com/lzf/myhfuteducn/LzfApplication.html#startService-android.content.Intent-"><code>startService(android.content.Intent)</code></a>，服务调用其android.app.Service #stopSelf（int）完成执行该命令时的方法。有关此内容的说明，但是，从已经注册{@link #registerReceiver}的BroadcastReceiver中使用此方法是可以的，因为此BroadcastReceiver的生命周期与另一个对象（注册它的对象）相关联。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>bindService</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>service</code> - 标识要连接的服务。 Intent必须指定显式组件名称。</dd>
<dd><code>conn</code> - 服务启动和停止时接收信息。 这必须是有效的ServiceConnection对象; 它不能为空。</dd>
<dd><code>flags</code> - 绑定的操作选项。可以是0，<code>Context.BIND_AUTO_CREATE</code>，<code>Context.BIND_DEBUG_UNBIND</code>，<code>Context.BIND_NOT_FOREGROUND</code>，<code>Context.BIND_ABOVE_CLIENT</code>，<code>Context.BIND_ALLOW_OOM_MANAGEMENT</code>或<code>Context.BIND_WAIVE_PRIORITY</code>。</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>如果您已成功绑定到该服务，则返回<code>true</code>; 如果未建立连接，则返回<code>false</code>，因此您将不会收到服务对象。 但是，您仍应调用<a href="../../../com/lzf/myhfuteducn/LzfApplication.html#unbindService-android.content.ServiceConnection-"><code>unbindService(android.content.ServiceConnection)</code></a>来释放连接。</dd>
</dl>
</li>
</ul>
<a name="unbindService-android.content.ServiceConnection-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>unbindService</h4>
<pre>public&nbsp;void&nbsp;unbindService(android.content.ServiceConnection&nbsp;conn)</pre>
<div class="block">断开与应用程序服务的连接。 重新启动服务后，您将不再接听回调，现在可以随时停止服务。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>unbindService</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>conn</code> - 先前提供给bindService（）的连接接口。 此参数不能为null。</dd>
</dl>
</li>
</ul>
<a name="startInstrumentation-android.content.ComponentName-java.lang.String-android.os.Bundle-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>startInstrumentation</h4>
<pre>public&nbsp;boolean&nbsp;startInstrumentation(android.content.ComponentName&nbsp;className,
                                    java.lang.String&nbsp;profileFile,
                                    android.os.Bundle&nbsp;arguments)</pre>
<div class="block">开始执行<code>Instrumentation</code>类。 给定的Instrumentation组件将通过终止其目标应用程序（如果当前正在运行），启动目标进程，实例化检测组件，然后让它驱动应用程序来运行。
 此函数不是同步的 - 它在仪器启动时和运行时立即返回。
 通常只允许对一个未签名的包或使用签名包签名的包运行检测（确保目标信任检测）。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>startInstrumentation</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>className</code> - 要运行的检测组件的名称。</dd>
<dd><code>profileFile</code> - 在检测运行时写入分析数据的可选路径，如果没有分析，则为null。</dd>
<dd><code>arguments</code> - 传递给检测的其他可选参数，或null。</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd><code>true</code>如果检测成功启动，否则<code>false</code>。</dd>
</dl>
</li>
</ul>
<a name="getSystemService-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getSystemService</h4>
<pre>public&nbsp;java.lang.Object&nbsp;getSystemService(java.lang.String&nbsp;name)</pre>
<div class="block">按名称将句柄返回到系统级服务。返回对象的类因请求的名称而异。目前可用的名称是：
 <code>Context.WINDOW_SERVICE</code>（“窗口”）
 顶级窗口管理器，您可以在其中放置自定义窗口。返回的对象是<code>WindowManager</code>。
 <code>Context.LAYOUT_INFLATER_SERVICE</code>（“layout_inflater”）
 用于在此上下文中展开布局资源的<code>LayoutInflater</code>。
 <code>Context.ACTIVITY_SERVICE</code>（“活动”）
 一个<code>ActivityManager</code>，用于与系统的全局活动状态进行交互。
 <code>Context.POWER_SERVICE</code>（“权力”）
 用于控制电源管理的<code>PowerManager</code>。
 <code>Context.ALARM_SERVICE</code>（“闹钟”）
 一个<code>AlarmManager</code>，用于在您选择时接收意图。
 <code>Context.NOTIFICATION_SERVICE</code>（“通知”）
 用于通知用户后台事件的<code>NotificationManager</code>。
 <code>Context.KEYGUARD_SERVICE</code>（“keyguard”）
 用于控制键盘锁的<code>KeyguardManager</code>。
 <code>Context.LOCATION_SERVICE</code>（“位置”）
  用于控制位置（例如，GPS）更新的<code>android.location.LocationManager</code>。
 <code>Context.SEARCH_SERVICE</code>（“搜索”）
 用于处理搜索的<code>SearchManager</code>。
 <code>Context.VIBRATOR_SERVICE</code>（“振动器”）
 用于与振动器硬件交互的<code>Vibrator</code>。
 <code>Context.CONNECTIVITY_SERVICE</code>（“连接”）
 用于处理网络连接管理的<code>ConnectivityManager</code>。
 <code>Context.WIFI_SERVICE</code>（“wifi”）
 用于管理Wi-Fi连接的<code>WifiManager</code>。在NYC之前的版本中，它应该只从应用程序上下文中获取，而不是从任何其他派生上下文中获取，以避免调用进程中的内存泄漏。
 <code>Context.WIFI_AWARE_SERVICE</code>（“wifiaware”）
 用于管理Wi-Fi Aware发现和连接的<code>WifiAwareManager</code>。
 （“wifip2p”）
 用于管理Wi-Fi Direct连接的<code>WifiP2pManager</code>。
 <code>Context.INPUT_METHOD_SERVICE</code>（“input_method”）
 用于管理输入方法的<code>InputMethodManager</code>。
 <code>Context.UI_MODE_SERVICE</code>（“uimode”）
 用于控制UI模式的<code>UiModeManager</code>。
 <code>Context.DOWNLOAD_SERVICE</code>（“下载”）
 用于请求HTTP下载的<code>DownloadManager</code>
 <code>Context.BATTERY_SERVICE</code>（“batterymanager”）
 用于管理电池状态的<code>BatteryManager</code>
 <code>Context.JOB_SCHEDULER_SERVICE</code>（“taskmanager”）
 用于管理计划任务的<code>android.app.job.JobScheduler</code>
 <code>Context.NETWORK_STATS_SERVICE</code>（“netstats”）
 用于查询网络使用情况统计信息的<code>NetworkStatsManager</code>。
 <code>Context.HARDWARE_PROPERTIES_SERVICE</code>（“hardware_properties”）
 用于访问硬件属性的<code>HardwarePropertiesManager</code>。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>getSystemService</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>name</code> - 所需服务的名称。</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>如果名称不存在，则为服务或null。</dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><code>Context.WINDOW_SERVICE</code>, 
<code>WindowManager</code>, 
<code>Context.LAYOUT_INFLATER_SERVICE</code>, 
<code>LayoutInflater</code>, 
<code>Context.ACTIVITY_SERVICE</code>, 
<code>ActivityManager</code>, 
<code>Context.POWER_SERVICE</code>, 
<code>PowerManager</code>, 
<code>Context.ALARM_SERVICE</code>, 
<code>AlarmManager</code>, 
<code>Context.NOTIFICATION_SERVICE</code>, 
<code>NotificationManager</code>, 
<code>Context.KEYGUARD_SERVICE</code>, 
<code>KeyguardManager</code>, 
<code>Context.LOCATION_SERVICE</code>, 
<code>android.location.LocationManager</code>, 
<code>Context.SEARCH_SERVICE</code>, 
<code>SearchManager</code>, 
<code>Context.SENSOR_SERVICE</code>, 
<code>android.hardware.SensorManager</code>, 
<code>Context.STORAGE_SERVICE</code>, 
<code>StorageManager</code>, 
<code>Context.VIBRATOR_SERVICE</code>, 
<code>Vibrator</code>, 
<code>Context.CONNECTIVITY_SERVICE</code>, 
<code>ConnectivityManager</code>, 
<code>Context.WIFI_SERVICE</code>, 
<code>android.net.wifi.WifiManager</code>, 
<code>Context.AUDIO_SERVICE</code>, 
<code>android.media.AudioManager</code>, 
<code>Context.MEDIA_ROUTER_SERVICE</code>, 
<code>android.media.MediaRouter</code>, 
<code>Context.TELEPHONY_SERVICE</code>, 
<code>android.telephony.TelephonyManager</code>, 
<code>Context.TELEPHONY_SUBSCRIPTION_SERVICE</code>, 
<code>android.telephony.SubscriptionManager</code>, 
<code>Context.CARRIER_CONFIG_SERVICE</code>, 
<code>android.telephony.CarrierConfigManager</code>, 
<code>Context.INPUT_METHOD_SERVICE</code>, 
<code>InputMethodManager</code>, 
<code>Context.UI_MODE_SERVICE</code>, 
<code>UiModeManager</code>, 
<code>Context.DOWNLOAD_SERVICE</code>, 
<code>DownloadManager</code>, 
<code>Context.BATTERY_SERVICE</code>, 
<code>BatteryManager</code>, 
<code>Context.JOB_SCHEDULER_SERVICE</code>, 
<code>android.app.job.JobScheduler</code>, 
<code>Context.NETWORK_STATS_SERVICE</code>, 
<code>android.app.usage.NetworkStatsManager</code>, 
<code>HardwarePropertiesManager</code>, 
<code>Context.HARDWARE_PROPERTIES_SERVICE</code></dd>
</dl>
</li>
</ul>
<a name="getSystemServiceName-java.lang.Class-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getSystemServiceName</h4>
<pre>public&nbsp;java.lang.String&nbsp;getSystemServiceName(java.lang.Class&lt;?&gt;&nbsp;serviceClass)</pre>
<div class="block">获取由指定类表示的系统级服务的名称。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>getSystemServiceName</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>serviceClass</code> - 所需服务的类。</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>如果类不是受支持的系统服务，则服务名称或null。</dd>
</dl>
</li>
</ul>
<a name="checkPermission-java.lang.String-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>checkPermission</h4>
<pre>public&nbsp;int&nbsp;checkPermission(java.lang.String&nbsp;permission,
                           int&nbsp;pid,
                           int&nbsp;uid)</pre>
<div class="block">检查特定的包是否获得了特定的权限。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>checkPermission</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>permission</code> - 正在检查的权限的名称。</dd>
<dd><code>pid</code> - 正在对进程ID进行检查。一定是> 0。</dd>
<dd><code>uid</code> - 要检查的用户ID。 uid为0是root用户，它将通过每个权限检查。</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd><code>PackageManager＃PERMISSION_GRANTED</code>如果给定的pid / uid允许该权限，或<code>PackageManager＃PERMISSION_DENIED</code>如果不允许。</dd>
</dl>
</li>
</ul>
<a name="checkCallingPermission-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>checkCallingPermission</h4>
<pre>public&nbsp;int&nbsp;checkCallingPermission(java.lang.String&nbsp;permission)</pre>
<div class="block">确定您正在处理的IPC的调用进程是否已被授予特定权限。 这与使用<code>android.os.Binder＃getCallingPid</code>和<code>#getCallingUid</code>返回的pid和uid调用<code>#checkPermission（String，int，int）</code>基本相同。
 一个重要的区别是，如果您当前没有处理IPC（Inter-Process Communication：跨进程通信），此功能将始终失败。 这样做是为了防止意外泄露权限; 您可以使用<a href="../../../com/lzf/myhfuteducn/LzfApplication.html#checkCallingOrSelfPermission-java.lang.String-"><code>checkCallingOrSelfPermission(java.lang.String)</code></a>来避免这种保护。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>checkCallingPermission</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>permission</code> - 正在检查的权限的名称。</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd><code>PackageManager＃PERMISSION_GRANTED</code>如果允许调用pid / uid该权限，或<code>PackageManager＃PERMISSION_DENIED</code>如果不允许。</dd>
</dl>
</li>
</ul>
<a name="checkCallingOrSelfPermission-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>checkCallingOrSelfPermission</h4>
<pre>public&nbsp;int&nbsp;checkCallingOrSelfPermission(java.lang.String&nbsp;permission)</pre>
<div class="block">确定IPC（Inter-Process Communication：跨进程通信）或您的调用进程是否已被授予特定权限。 这与<a href="../../../com/lzf/myhfuteducn/LzfApplication.html#checkCallingPermission-java.lang.String-"><code>checkCallingPermission(java.lang.String)</code></a>相同，但如果您当前没有处理IPC（Inter-Process Communication：跨进程通信），它会授予您自己的权限。 小心使用！</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>checkCallingOrSelfPermission</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>permission</code> - 正在检查的权限的名称。</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd><code>PackageManager＃PERMISSION_GRANTED</code>如果允许调用pid / uid该权限，或<code>PackageManager＃PERMISSION_DENIED</code>如果不允许。</dd>
</dl>
</li>
</ul>
<a name="checkSelfPermission-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>checkSelfPermission</h4>
<pre>public&nbsp;int&nbsp;checkSelfPermission(java.lang.String&nbsp;permission)</pre>
<div class="block">确定是否获得了特定的权限。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>checkSelfPermission</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>permission</code> - 正在检查的权限的名称。</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd><code>PackageManager＃PERMISSION_GRANTED</code>如果允许调用pid / uid该权限，或<code>PackageManager＃PERMISSION_DENIED</code>如果不允许。</dd>
</dl>
</li>
</ul>
<a name="enforcePermission-java.lang.String-int-int-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>enforcePermission</h4>
<pre>public&nbsp;void&nbsp;enforcePermission(java.lang.String&nbsp;permission,
                              int&nbsp;pid,
                              int&nbsp;uid,
                              java.lang.String&nbsp;message)</pre>
<div class="block">如果对系统中运行的特定进程和用户标识不允许给定权限，则抛出<code>SecurityException</code>。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>enforcePermission</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>permission</code> - 正在检查的权限的名称。</dd>
<dd><code>pid</code> - 正在对进程ID进行检查。一定是> 0。</dd>
<dd><code>uid</code> - 要检查的用户ID。 uid为0是root用户，它将通过每个权限检查。</dd>
<dd><code>message</code> - 如果抛出异常，则在异常中包含一条消息。</dd>
</dl>
</li>
</ul>
<a name="enforceCallingPermission-java.lang.String-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>enforceCallingPermission</h4>
<pre>public&nbsp;void&nbsp;enforceCallingPermission(java.lang.String&nbsp;permission,
                                     java.lang.String&nbsp;message)</pre>
<div class="block">如果您正在处理的IPC的调用进程未被授予特定权限，请抛出<code>SecurityException</code>。
 这与使用<code>#getCallingPid</code>和<code>#enforcePermission（String，int，int，String）}基本相同getCallingUid</code>。
 一个重要的区别是，如果您当前没有处理IPC，则此函数将始终抛出SecurityException。 这样做是为了防止意外泄露权限; 您可以使用<a href="../../../com/lzf/myhfuteducn/LzfApplication.html#enforceCallingOrSelfPermission-java.lang.String-java.lang.String-"><code>enforceCallingOrSelfPermission(java.lang.String, java.lang.String)</code></a>来避免这种保护。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>enforceCallingPermission</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>permission</code> - 正在检查的权限的名称。</dd>
<dd><code>message</code> - 如果抛出异常，则在异常中包含一条消息。</dd>
</dl>
</li>
</ul>
<a name="enforceCallingOrSelfPermission-java.lang.String-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>enforceCallingOrSelfPermission</h4>
<pre>public&nbsp;void&nbsp;enforceCallingOrSelfPermission(java.lang.String&nbsp;permission,
                                           java.lang.String&nbsp;message)</pre>
<div class="block">如果您和您正在处理的IPC的调用进程都未被授予特定权限，请抛出<code>SecurityException</code>。 这与<a href="../../../com/lzf/myhfuteducn/LzfApplication.html#enforceCallingPermission-java.lang.String-java.lang.String-"><code>enforceCallingPermission(java.lang.String, java.lang.String)</code></a>相同，但如果您当前没有处理IPC，它会授予您自己的权限。 小心使用！</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>enforceCallingOrSelfPermission</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>permission</code> - 正在检查的权限的名称。</dd>
<dd><code>message</code> - 如果抛出异常，则在异常中包含一条消息。</dd>
</dl>
</li>
</ul>
<a name="grantUriPermission-java.lang.String-android.net.Uri-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>grantUriPermission</h4>
<pre>public&nbsp;void&nbsp;grantUriPermission(java.lang.String&nbsp;toPackage,
                               android.net.Uri&nbsp;uri,
                               int&nbsp;modeFlags)</pre>
<div class="block">授予访问特定Uri到另一个包的权限，无论该包是否具有访问Uri内容提供者的一般权限。这可以用于授予特定的临时权限，通常是为了响应用户交互（例如用户打开您希望其他人显示的附件）。
 通常，您应该使用<code>#FLAG_GRANT_READ_URI_PERMISSION Intent.FLAG_GRANT_READ_URI_PERMISSION</code>或<code>#FLAG_GRANT_WRITE_URI_PERMISSION Intent.FLAG_GRANT_WRITE_URI_PERMISSION</code>，并使用Intent直接启动活动而不是此功能。如果直接使用此功能，则应该确保在不再允许目标访问它时调用<a href="../../../com/lzf/myhfuteducn/LzfApplication.html#revokeUriPermission-android.net.Uri-int-"><code>revokeUriPermission(android.net.Uri, int)</code></a>。
 要成功，拥有Uri的内容提供商必须在其清单中设置@link android.R.styleable#AndroidManifestProvider_grantUriPermissions <grantUriPermissions/>} 属性或标签。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>grantUriPermission</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>toPackage</code> - 您希望允许访问Uri的包。</dd>
<dd><code>uri</code> - 要授予访问权的Uri。</dd>
<dd><code>modeFlags</code> - 所需的访问模式。</dd>
</dl>
</li>
</ul>
<a name="revokeUriPermission-android.net.Uri-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>revokeUriPermission</h4>
<pre>public&nbsp;void&nbsp;revokeUriPermission(android.net.Uri&nbsp;uri,
                                int&nbsp;modeFlags)</pre>
<div class="block">删除以前使用<a href="../../../com/lzf/myhfuteducn/LzfApplication.html#grantUriPermission-java.lang.String-android.net.Uri-int-"><code>grantUriPermission(java.lang.String, android.net.Uri, int)</code></a>或任何其他机制添加的特定内容提供商Uri的所有权限。给定的Uri将匹配所有先前授予的Uris，这些Uris是相同的或者是给定Uri的子路径。也就是说，它不会删除任何更高级别的前缀授予。
 在<code>android.os.Build.VERSION_CODES＃LOLLIPOP</code>之前，如果您没有对Uri的常规权限访问权限，但是通过特定的Uri权限授予获得了访问权限，则无法使用此功能撤销该授权并抛出<code>SecurityException</code>。
 从<code>android.os.Build.VERSION_CODES＃LOLLIPOP</code>开始，此函数不会抛出安全异常，但会删除向应用程序授予Uri的任何权限（或者没有）。
 与<code>#revokeUriPermission（String，Uri，int）</code>不同，此方法通过任何已发生的机制影响与给定Uri匹配的所有权限授予（例如：间接通过剪贴板，activity launch, service start, 等）。 这意味着这可能具有潜在的危险性，因为它可以撤销其他应用程序可能强烈期望坚持的拨款。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>revokeUriPermission</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>uri</code> - 您想要撤销访问的Uri。</dd>
<dd><code>modeFlags</code> - 要撤销的访问模式。</dd>
</dl>
</li>
</ul>
<a name="revokeUriPermission-java.lang.String-android.net.Uri-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>revokeUriPermission</h4>
<pre>public&nbsp;void&nbsp;revokeUriPermission(java.lang.String&nbsp;targetPackage,
                                android.net.Uri&nbsp;uri,
                                int&nbsp;modeFlags)</pre>
<div class="block">删除访问特定内容提供程序Uri的权限，该特定内容提供程序Uri之前已添加<a href="../../../com/lzf/myhfuteducn/LzfApplication.html#grantUriPermission-java.lang.String-android.net.Uri-int-"><code>grantUriPermission(java.lang.String, android.net.Uri, int)</code></a>以用于特定目标程序包。 给定的Uri将匹配所有先前授予的Uris，这些Uris是相同的或者是给定Uri的子路径。 也就是说，它不会删除任何更高级别的前缀授予。
 与<code>#revokeUriPermission（Uri，int）</code>不同，此方法仅撤销已通过<a href="../../../com/lzf/myhfuteducn/LzfApplication.html#grantUriPermission-java.lang.String-android.net.Uri-int-"><code>grantUriPermission(java.lang.String, android.net.Uri, int)</code></a>明确授予的权限，且仅用于指定的包。 通过其他机制（剪贴板，activity launch, service start, 等）发生的任何匹配授权都不会被删除。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>revokeUriPermission</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>targetPackage</code> - 先前授予访问权限的包。</dd>
<dd><code>uri</code> - 您想要撤销访问的Uri。</dd>
<dd><code>modeFlags</code> - 要撤销的访问模式。</dd>
</dl>
</li>
</ul>
<a name="checkUriPermission-android.net.Uri-int-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>checkUriPermission</h4>
<pre>public&nbsp;int&nbsp;checkUriPermission(android.net.Uri&nbsp;uri,
                              int&nbsp;pid,
                              int&nbsp;uid,
                              int&nbsp;modeFlags)</pre>
<div class="block">确定是否已授予特定进程和用户标识访问特定URI的权限。 这仅检查已明确授予的权限 - 如果给定的进程/ uid具有对URI的内容提供者的更一般访问权限，则此检查将始终失败。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>checkUriPermission</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>uri</code> - 正在检查的uri。</dd>
<dd><code>pid</code> - 正在对进程ID进行检查。一定是> 0。</dd>
<dd><code>uid</code> - 要检查的用户ID。 uid为0是root用户，它将通过每个权限检查。</dd>
<dd><code>modeFlags</code> - 要检查的访问模式。</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd><code>PackageManager＃PERMISSION_GRANTED</code>如果允许调用pid / uid该权限，或<code>PackageManager＃PERMISSION_DENIED</code>如果不允许。</dd>
</dl>
</li>
</ul>
<a name="checkCallingUriPermission-android.net.Uri-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>checkCallingUriPermission</h4>
<pre>public&nbsp;int&nbsp;checkCallingUriPermission(android.net.Uri&nbsp;uri,
                                     int&nbsp;modeFlags)</pre>
<div class="block">确定是否已授予调用进程和用户标识访问特定URI的权限。 这与使用<code>android.os.Binder＃getCallingPid</code>和<code>#checkUriPermission（Uri，int，int，int）}基本相同getCallingUid</code>。
 一个重要的区别是，如果您当前没有处理IPC，此功能将始终失败。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>checkCallingUriPermission</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>uri</code> - 正在检查的uri。</dd>
<dd><code>modeFlags</code> - 检查的访问模式。</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd><code>PackageManager＃PERMISSION_GRANTED</code>如果允许调用pid / uid该权限，或<code>PackageManager＃PERMISSION_DENIED</code>如果不允许。</dd>
</dl>
</li>
</ul>
<a name="checkCallingOrSelfUriPermission-android.net.Uri-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>checkCallingOrSelfUriPermission</h4>
<pre>public&nbsp;int&nbsp;checkCallingOrSelfUriPermission(android.net.Uri&nbsp;uri,
                                           int&nbsp;modeFlags)</pre>
<div class="block">确定IPC 或 调用进程是否已被授予访问特定URI的权限。 这与<a href="../../../com/lzf/myhfuteducn/LzfApplication.html#checkCallingUriPermission-android.net.Uri-int-"><code>checkCallingUriPermission(android.net.Uri, int)</code></a>相同，但如果您当前没有处理IPC，它会授予您自己的权限。 小心使用！</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>checkCallingOrSelfUriPermission</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>uri</code> - 正在检查的uri。</dd>
<dd><code>modeFlags</code> - 检查的访问模式。</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd><code>PackageManager＃PERMISSION_GRANTED</code>如果允许调用pid / uid该权限，或<code>PackageManager＃PERMISSION_DENIED</code>如果不允许。</dd>
</dl>
</li>
</ul>
<a name="checkUriPermission-android.net.Uri-java.lang.String-java.lang.String-int-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>checkUriPermission</h4>
<pre>public&nbsp;int&nbsp;checkUriPermission(android.net.Uri&nbsp;uri,
                              java.lang.String&nbsp;readPermission,
                              java.lang.String&nbsp;writePermission,
                              int&nbsp;pid,
                              int&nbsp;uid,
                              int&nbsp;modeFlags)</pre>
<div class="block">检查Uri和正常权限。 这允许您在一次调用中同时执行<a href="../../../com/lzf/myhfuteducn/LzfApplication.html#checkPermission-java.lang.String-int-int-"><code>checkPermission(java.lang.String, int, int)</code></a>和<a href="../../../com/lzf/myhfuteducn/LzfApplication.html#checkUriPermission-android.net.Uri-int-int-int-"><code>checkUriPermission(android.net.Uri, int, int, int)</code></a>。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>checkUriPermission</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>uri</code> - 要检查其权限的Uri，或为不执行此检查的null。</dd>
<dd><code>readPermission</code> - 提供整体读访问权限的权限，或者为不执行此检查的null。</dd>
<dd><code>writePermission</code> - 提供整体写访问权限的权限，或者为不执行此检查的null。</dd>
<dd><code>pid</code> - 正在对进程ID进行检查。一定是> 0。</dd>
<dd><code>uid</code> - uid为0是root用户，它将通过每个权限检查。</dd>
<dd><code>modeFlags</code> - 检查的访问模式。</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd><code>PackageManager＃PERMISSION_GRANTED</code>如果允许调用者访问该URI或拥有其中一个给定权限，或者<code>PackageManager＃PERMISSION_DENIED</code>如果不允许。</dd>
</dl>
</li>
</ul>
<a name="enforceUriPermission-android.net.Uri-int-int-int-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>enforceUriPermission</h4>
<pre>public&nbsp;void&nbsp;enforceUriPermission(android.net.Uri&nbsp;uri,
                                 int&nbsp;pid,
                                 int&nbsp;uid,
                                 int&nbsp;modeFlags,
                                 java.lang.String&nbsp;message)</pre>
<div class="block">如果未授予特定进程和用户标识访问特定URI的权限，请抛出<code>SecurityException</code>。 这仅检查已明确授予的权限 - 如果给定的进程/ uid具有对URI的内容提供者的更一般访问权限，则此检查将始终失败。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>enforceUriPermission</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>uri</code> - 正在检查的uri。</dd>
<dd><code>pid</code> - 正在对进程ID进行检查。一定是> 0。</dd>
<dd><code>uid</code> - uid为0是root用户，它将通过每个权限检查。</dd>
<dd><code>modeFlags</code> - 要强制执行的访问模式。</dd>
<dd><code>message</code> - 如果抛出则包含在异常中的消息。</dd>
</dl>
</li>
</ul>
<a name="enforceCallingUriPermission-android.net.Uri-int-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>enforceCallingUriPermission</h4>
<pre>public&nbsp;void&nbsp;enforceCallingUriPermission(android.net.Uri&nbsp;uri,
                                        int&nbsp;modeFlags,
                                        java.lang.String&nbsp;message)</pre>
<div class="block">如果未授予调用进程和用户标识访问特定URI的权限，请抛出<code>SecurityException</code>。
 这与使用<code>#getCallingPid</code>和<code>Binder.getCallingUid()</code>返回的pid和uid调用<code>#enforceUriPermission（Uri，int，int，int，String）</code>基本相同。活页夹＃getCallingUid}。
 一个重要的区别是，如果您当前没有处理IPC，此函数将始终抛出SecurityException。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>enforceCallingUriPermission</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>uri</code> - 正在检查的uri。</dd>
<dd><code>modeFlags</code> - 要强制执行的访问模式。</dd>
<dd><code>message</code> - 如果抛出则包含在异常中的消息。</dd>
</dl>
</li>
</ul>
<a name="enforceCallingOrSelfUriPermission-android.net.Uri-int-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>enforceCallingOrSelfUriPermission</h4>
<pre>public&nbsp;void&nbsp;enforceCallingOrSelfUriPermission(android.net.Uri&nbsp;uri,
                                              int&nbsp;modeFlags,
                                              java.lang.String&nbsp;message)</pre>
<div class="block">如果IPC  或调用进程未被授予访问特定URI的权限，请抛出<code>SecurityException</code>。 这与<a href="../../../com/lzf/myhfuteducn/LzfApplication.html#enforceCallingUriPermission-android.net.Uri-int-java.lang.String-"><code>enforceCallingUriPermission(android.net.Uri, int, java.lang.String)</code></a>相同，但如果您当前没有处理IPC，它会授予您自己的权限。 小心使用！</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>enforceCallingOrSelfUriPermission</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>uri</code> - 正在检查的uri。</dd>
<dd><code>modeFlags</code> - 要强制执行的访问模式。</dd>
<dd><code>message</code> - 如果抛出则包含在异常中的消息。</dd>
</dl>
</li>
</ul>
<a name="enforceUriPermission-android.net.Uri-java.lang.String-java.lang.String-int-int-int-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>enforceUriPermission</h4>
<pre>public&nbsp;void&nbsp;enforceUriPermission(android.net.Uri&nbsp;uri,
                                 java.lang.String&nbsp;readPermission,
                                 java.lang.String&nbsp;writePermission,
                                 int&nbsp;pid,
                                 int&nbsp;uid,
                                 int&nbsp;modeFlags,
                                 java.lang.String&nbsp;message)</pre>
<div class="block">强制执行Uri和正常权限。 这允许您在一次调用中同时执行<a href="../../../com/lzf/myhfuteducn/LzfApplication.html#enforcePermission-java.lang.String-int-int-java.lang.String-"><code>enforcePermission(java.lang.String, int, int, java.lang.String)</code></a>和<a href="../../../com/lzf/myhfuteducn/LzfApplication.html#enforceUriPermission-android.net.Uri-int-int-int-java.lang.String-"><code>enforceUriPermission(android.net.Uri, int, int, int, java.lang.String)</code></a>。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>enforceUriPermission</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>uri</code> - 要检查其权限的Uri，或为不执行此检查的null。</dd>
<dd><code>readPermission</code> - 提供整体读访问权限的权限，或者为不执行此检查的null。</dd>
<dd><code>writePermission</code> - 提供整体写访问权限的权限，或者为不执行此检查的null。</dd>
<dd><code>pid</code> - 正在对进程ID进行检查。一定是> 0。</dd>
<dd><code>uid</code> - uid为0是root用户，它将通过每个权限检查。</dd>
<dd><code>modeFlags</code> - 要强制执行的访问模式。</dd>
<dd><code>message</code> - 如果抛出则包含在异常中的消息。</dd>
</dl>
</li>
</ul>
<a name="createPackageContext-java.lang.String-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createPackageContext</h4>
<pre>public&nbsp;android.content.Context&nbsp;createPackageContext(java.lang.String&nbsp;packageName,
                                                    int&nbsp;flags)
                                             throws android.content.pm.PackageManager.NameNotFoundException</pre>
<div class="block">返回给定应用程序名称的新Context对象。 此Context与命名应用程序在启动时获得的内容相同，包含相同的资源和类加载器。
 每次调用此方法都会返回Context对象的新实例; Context对象不是共享的，但它们共享公共状态（Resources，ClassLoader等），因此Context实例本身相当轻量级。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>createPackageContext</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>packageName</code> - 应用程序包的名称。</dd>
<dd><code>flags</code> - 选择标记。</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>应用程序的{<code>Context</code>}</dd>
<dt><span class="throwsLabel">抛出:</span></dt>
<dd><code>PackageManager.NameNotFoundException</code> - 如果没有具有给定包名称的应用程序。</dd>
</dl>
</li>
</ul>
<a name="createConfigurationContext-android.content.res.Configuration-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createConfigurationContext</h4>
<pre>public&nbsp;android.content.Context&nbsp;createConfigurationContext(android.content.res.Configuration&nbsp;overrideConfiguration)</pre>
<div class="block">为当前Context返回一个新的Context对象，但调整其资源以匹配给定的Configuration。
 每次调用此方法都会返回Context对象的新实例; 上下文对象不是共享的，但是常见的状态（ClassLoader，相同配置的其他资源）可能因此Context本身可以相当轻量级。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>createConfigurationContext</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>overrideConfiguration</code> - <code>Configuration</code>指定在原始Context资源的基本配置中要修改的值。 如果基本配置发生更改（例如由于方向更改），则此上下文的资源也将更改，除非已在此处显式覆盖了值。</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>具有给定配置覆盖的{<code>Context</code>}。</dd>
</dl>
</li>
</ul>
<a name="createDisplayContext-android.view.Display-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createDisplayContext</h4>
<pre>public&nbsp;android.content.Context&nbsp;createDisplayContext(android.view.Display&nbsp;display)</pre>
<div class="block">为当前Context返回一个新的Context对象，但调整其资源以匹配给定Display的度量。
 每次调用此方法都会返回Context对象的新实例; 上下文对象不是共享的，但是常见的状态（ClassLoader，相同配置的其他资源）可能因此Context本身可以相当轻量级。
 返回的显示上下文提供 <code>WindowManager</code>（请参阅<code>#getSystemService（String）</code>），其配置为在给定显示器上显示窗口。 WindowManager的<code>android.view.WindowManager＃getDefaultDisplay</code>方法可用于从返回的Context中检索Display。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>createDisplayContext</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>display</code> - 一个<code>Display</code>对象，指定显示其指标的显示应该定制Context的资源以及应该显示哪些新窗口。</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>显示{<code>Context</code>}。</dd>
</dl>
</li>
</ul>
<a name="isRestricted--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isRestricted</h4>
<pre>public&nbsp;boolean&nbsp;isRestricted()</pre>
<div class="block">表示这种情况下是否受到限制。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>isRestricted</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd><code>true</code>如果此上下文受限制，<code>false</code>否则。</dd>
</dl>
</li>
</ul>
<a name="createDeviceProtectedStorageContext--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createDeviceProtectedStorageContext</h4>
<pre>public&nbsp;android.content.Context&nbsp;createDeviceProtectedStorageContext()</pre>
<div class="block">返回当前Context的新Context对象，但其存储API由受设备保护的存储支持。
 在具有直接引导的设备上，存储在此位置的数据使用绑定到物理设备的密钥进行加密，并且可以在设备成功引导后立即访问，在用户使用其凭据进行身份验证之前和之后（例如锁定模式或PIN）。
 由于设备保护的数据在没有用户身份验证的情况下可用，因此您应该使用此Context仔细限制存储的数据。例如，强烈建议不要在设备保护区域中存储敏感的身份验证令牌或密码。
 如果底层设备无法使用不同的密钥存储受设备保护和凭据保护的数据，则两个存储区域将同时可用。它们仍然是磁盘上的两个不同存储位置，只有可用性窗口会发生变化。
 每次调用此方法都会返回Context对象的新实例;上下文对象不是共享的，但是常见的状态（ClassLoader，相同配置的其他资源）可能因此Context本身可以相当轻量级。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>createDeviceProtectedStorageContext</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>返回当前Context的新Context对象</dd>
</dl>
</li>
</ul>
<a name="isDeviceProtectedStorage--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isDeviceProtectedStorage</h4>
<pre>public&nbsp;boolean&nbsp;isDeviceProtectedStorage()</pre>
<div class="block">指示此上下文的存储API是否由受设备保护的存储支持。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>isDeviceProtectedStorage</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
</dl>
</li>
</ul>
<a name="createContextForSplit-java.lang.String-">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>createContextForSplit</h4>
<pre>public&nbsp;android.content.Context&nbsp;createContextForSplit(java.lang.String&nbsp;splitName)
                                              throws android.content.pm.PackageManager.NameNotFoundException</pre>
<div class="block">返回给定拆分名称的新Context对象。 新的Context有一个ClassLoader和Resources对象，可以访问split及其所有依赖项的代码/资源。
 每次调用此方法都会返回Context对象的新实例; 上下文对象不是共享的，但是常见的状态（ClassLoader，同一拆分的其他资源）可能因此Context本身可以相当轻量级。</div>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>createContextForSplit</code>&nbsp;在类中&nbsp;<code>android.content.ContextWrapper</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>splitName</code> - 要包含的拆分的名称，如split的 AndroidManifest.xml 中所声明的。</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>一个{<code>Context</code>}，加载了给定的分割代码和/或资源。</dd>
<dt><span class="throwsLabel">抛出:</span></dt>
<dd><code>PackageManager.NameNotFoundException</code></dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="跳过导航链接">跳过导航链接</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="导航">
<li><a href="../../../overview-summary.html">概览</a></li>
<li><a href="package-summary.html">程序包</a></li>
<li class="navBarCell1Rev">类</li>
<li><a href="class-use/LzfApplication.html">使用</a></li>
<li><a href="package-tree.html">树</a></li>
<li><a href="../../../deprecated-list.html">已过时</a></li>
<li><a href="../../../index-files/index-1.html">索引</a></li>
<li><a href="../../../help-doc.html">帮助</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../com/lzf/myhfuteducn/LoginActivity.html" title="com.lzf.myhfuteducn中的类"><span class="typeNameLink">上一个类</span></a></li>
<li><a href="../../../com/lzf/myhfuteducn/MainActivity.html" title="com.lzf.myhfuteducn中的类"><span class="typeNameLink">下一个类</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?com/lzf/myhfuteducn/LzfApplication.html" target="_top">框架</a></li>
<li><a href="LzfApplication.html" target="_top">无框架</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../allclasses-noframe.html">所有类</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>概要:&nbsp;</li>
<li><a href="#nested.classes.inherited.from.class.android.app.Application">嵌套</a>&nbsp;|&nbsp;</li>
<li><a href="#fields.inherited.from.class.android.content.Context">字段</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">构造器</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">方法</a></li>
</ul>
<ul class="subNavList">
<li>详细资料:&nbsp;</li>
<li>字段&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">构造器</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">方法</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
